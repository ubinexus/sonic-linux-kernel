diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 8fe4a0fd6ef1..ee28b6247d02 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -1105,3 +1105,37 @@ config MMC_OWL
 
 config MMC_SDHCI_EXTERNAL_DMA
 	bool
+
+config MMC_PHYTIUM_SDCI
+	tristate "Phytium SD Host Controller support"
+	depends on ARCH_PHYTIUM || COMPILE_TEST
+	default y if ARCH_PHYTIUM
+	help
+	  This selects support for the SD/MMC Host Controller on
+	  Phytium SoC family.
+
+	  If you have a controller with this interface, say Y or M here.
+
+	  If unsure, say N.
+
+config MMC_PHYTIUM_MCI_PCI
+	tristate "Phytium octopus PCI MultiMedia Card Interface support"
+	depends on ARCH_PHYTIUM
+	default y if ARCH_PHYTIUM
+	help
+	  This selects support for the PCI MultiMedia Card Interface on Phytium
+	  px210 chipset.
+
+	  If you have a controller with this interface, say Y or M here.
+
+	  If unsure, say N.
+
+config MMC_PHYTIUM_MCI_PLTFM
+	tristate "Phytium MultiMedia Card Interface support"
+	depends on ARCH_PHYTIUM && OF
+	default y if ARCH_PHYTIUM
+        help
+          This selects support for the MultiMedia Card Interface on Phytium SoCs.
+	  If you have a controller with this interface, say Y or M here.
+
+	  If unsure, say N.
diff --git a/drivers/mmc/host/Makefile b/drivers/mmc/host/Makefile
index 451c25fc2c69..4a46cf083070 100644
--- a/drivers/mmc/host/Makefile
+++ b/drivers/mmc/host/Makefile
@@ -77,6 +77,7 @@ obj-$(CONFIG_MMC_USDHI6ROL0)	+= usdhi6rol0.o
 obj-$(CONFIG_MMC_TOSHIBA_PCI)	+= toshsd.o
 obj-$(CONFIG_MMC_BCM2835)	+= bcm2835.o
 obj-$(CONFIG_MMC_OWL)		+= owl-mmc.o
+obj-$(CONFIG_MMC_PHYTIUM_SDCI)	+= phytium-sdci.o
 
 obj-$(CONFIG_MMC_REALTEK_PCI)	+= rtsx_pci_sdmmc.o
 obj-$(CONFIG_MMC_REALTEK_USB)	+= rtsx_usb_sdmmc.o
@@ -112,3 +113,6 @@ endif
 
 obj-$(CONFIG_MMC_SDHCI_XENON)	+= sdhci-xenon-driver.o
 sdhci-xenon-driver-y		+= sdhci-xenon.o sdhci-xenon-phy.o
+
+obj-$(CONFIG_MMC_PHYTIUM_MCI_PCI)	+= phytium-mci-pci.o phytium-mci.o
+obj-$(CONFIG_MMC_PHYTIUM_MCI_PLTFM)	+= phytium-mci-plat.o phytium-mci.o
diff --git a/drivers/mmc/host/phytium-mci-pci.c b/drivers/mmc/host/phytium-mci-pci.c
new file mode 100644
index 000000000000..bd193bbd0ccd
--- /dev/null
+++ b/drivers/mmc/host/phytium-mci-pci.c
@@ -0,0 +1,175 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Phytium Multimedia Card Interface PCI driver
+ *
+ * Copyright (c) 2020-2024 Phytium Technology Co., Ltd.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/irq.h>
+#include <linux/pm.h>
+#include <linux/pm_runtime.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include "phytium-mci.h"
+
+static u32 sd_caps = MMC_CAP_SD_HIGHSPEED | MMC_CAP_WAIT_WHILE_BUSY | MMC_CAP_CMD23 |
+		     MMC_CAP_4_BIT_DATA;
+static u32 sd_caps2 = MMC_CAP2_NO_MMC;
+
+static u32 emmc_caps = MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA | MMC_CAP_WAIT_WHILE_BUSY |
+		       MMC_CAP_CMD23 | MMC_CAP_HW_RESET | MMC_CAP_MMC_HIGHSPEED |
+		       MMC_CAP_NONREMOVABLE;
+static u32 emmc_caps2 = MMC_CAP2_NO_SDIO | MMC_CAP2_NO_SD;
+
+#define PCI_BAR_NO 0
+
+#if defined CONFIG_PM && defined CONFIG_PM_SLEEP
+static const struct dev_pm_ops phytium_mci_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(phytium_mci_suspend,
+				phytium_mci_resume)
+	SET_RUNTIME_PM_OPS(phytium_mci_runtime_suspend,
+			   phytium_mci_runtime_resume, NULL)
+};
+#else
+#define phytium_mci_dev_pm_ops NULL
+#endif
+
+static int
+phytium_mci_pci_probe(struct pci_dev *pdev, const struct pci_device_id *pid)
+{
+	struct phytium_mci_host *host;
+	struct mmc_host *mmc;
+	int ret;
+
+	ret = pcim_enable_device(pdev);
+
+	if (ret)
+		return ret;
+	pci_set_master(pdev);
+
+	mmc = mmc_alloc_host(sizeof(struct phytium_mci_host), &pdev->dev);
+
+	if (!mmc)
+		return -ENOMEM;
+
+	host = mmc_priv(mmc);
+
+	pci_enable_msi(pdev);
+
+	host->irq = pdev->irq;
+	host->irq_flags = IRQF_SHARED;
+	host->dev = &pdev->dev;
+	ret = pcim_iomap_regions(pdev, 1 << PCI_BAR_NO, pci_name(pdev));
+
+	if (ret) {
+		dev_err(&pdev->dev, "I/O memory remapping failed\n");
+		goto host_free;
+	}
+
+	host->base = pcim_iomap_table(pdev)[PCI_BAR_NO];
+	host->is_use_dma = 1;
+	host->is_device_x100 = 1;
+
+	if (pdev->devfn == 2) {
+		host->caps = emmc_caps;
+		host->caps2 = emmc_caps2;
+	} else {
+		host->caps = sd_caps;
+		host->caps2 = sd_caps2;
+		mmc->f_max = 25000000; /* stable frequency */
+	}
+
+	host->mmc = mmc;
+	host->clk_rate = MCI_CLK;
+
+	dev_info(&pdev->dev, "%s %d: [bar %d] addr: 0x%llx size: 0x%llx km: 0x%llx devfn:%d\n",
+		 __func__, __LINE__, PCI_BAR_NO, pci_resource_start(pdev, 0),
+		 pci_resource_len(pdev, 0), (uint64_t)host->base, pdev->devfn);
+
+	dev_dbg(&pdev->dev, "%s %d:irq:0x%x\n", __func__, __LINE__, host->irq);
+
+	ret = phytium_mci_common_probe(host);
+
+	if (ret == MCI_REALEASE_MEM) {
+		ret = -ENOMEM;
+		goto release_mem;
+	} else if (ret) {
+		goto release;
+	}
+	pci_set_drvdata(pdev, mmc);
+	dev_info(&pdev->dev, "%s %d: probe phytium mci successful.\n", __func__, __LINE__);
+	return 0;
+
+release:
+	phytium_mci_deinit_hw(host);
+release_mem:
+
+	if (host->dma.adma_table) {
+		dma_free_coherent(&pdev->dev,
+					MAX_BD_NUM * sizeof(struct phytium_adma2_64_desc),
+					host->dma.adma_table, host->dma.adma_addr);
+	}
+host_free:
+	mmc_free_host(mmc);
+	pci_disable_device(pdev);
+	return ret;
+}
+
+static void phytium_mci_pci_remove(struct pci_dev *pdev)
+{
+	struct phytium_mci_host *host;
+	struct mmc_host *mmc;
+
+	mmc = pci_get_drvdata(pdev);
+	if (!mmc) {
+		dev_info(&pdev->dev, "%s %d: mmc is null.\n", __func__, __LINE__);
+		return;
+	}
+	host = mmc_priv(mmc);
+	if (!host) {
+		dev_info(&pdev->dev, "%s %d: host is null.\n", __func__, __LINE__);
+		mmc_remove_host(mmc);
+		mmc_free_host(mmc);
+		return;
+	}
+
+	del_timer(&host->hotplug_timer);
+
+	mmc_remove_host(host->mmc);
+
+	if (host->dma.adma_table) {
+		dma_free_coherent(&pdev->dev,
+				  MAX_BD_NUM * sizeof(struct phytium_adma2_64_desc),
+				  host->dma.adma_table, host->dma.adma_addr);
+	}
+	phytium_mci_deinit_hw(host);
+	mmc_free_host(mmc);
+	pci_set_drvdata(pdev, NULL);
+}
+
+static const struct pci_device_id phytium_mci_pci_tbl[] = {
+	{
+		PCI_DEVICE(PCI_VENDOR_ID_PHYTIUM, 0xdc28),
+		.class		= 0x5,
+		.class_mask	= 0,
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(pci, phytium_mci_pci_tbl);
+
+static struct pci_driver phytium_mci_pci_driver = {
+	.name		= "phytium-mci-pci",
+	.id_table	= phytium_mci_pci_tbl,
+	.probe		= phytium_mci_pci_probe,
+	.remove		= phytium_mci_pci_remove,
+	.driver	= {
+		.pm	= &phytium_mci_dev_pm_ops,
+	}
+};
+module_pci_driver(phytium_mci_pci_driver);
+
+MODULE_DESCRIPTION("Phytium Multimedia Card Interface PCI driver");
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Cheng Quan <chengquan@phytium.com.cn>");
diff --git a/drivers/mmc/host/phytium-mci-plat.c b/drivers/mmc/host/phytium-mci-plat.c
new file mode 100644
index 000000000000..212c86da7bb6
--- /dev/null
+++ b/drivers/mmc/host/phytium-mci-plat.c
@@ -0,0 +1,175 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Phytium Multimedia Card Interface PCI driver
+ *
+ * Copyright (c) 2021-2024 Phytium Technology Co., Ltd.
+ */
+
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/pm_runtime.h>
+#include <linux/acpi.h>
+#include <linux/dma-mapping.h>
+#include "phytium-mci.h"
+
+static u32 mci_caps = MMC_CAP_CMD23;
+
+#if defined CONFIG_PM && defined CONFIG_PM_SLEEP
+
+static const struct dev_pm_ops phytium_mci_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(phytium_mci_suspend,
+				phytium_mci_resume)
+	SET_RUNTIME_PM_OPS(phytium_mci_runtime_suspend,
+			   phytium_mci_runtime_resume, NULL)
+};
+#else
+#define phytium_mci_dev_pm_ops NULL
+#endif
+
+static int phytium_mci_probe(struct platform_device *pdev)
+{
+	struct mmc_host *mmc;
+	struct phytium_mci_host *host;
+	struct resource *res;
+	const struct acpi_device_id *match;
+	struct device *dev = &pdev->dev;
+	int ret;
+
+	mmc = mmc_alloc_host(sizeof(struct phytium_mci_host), &pdev->dev);
+	if (!mmc)
+		return -ENOMEM;
+	host = mmc_priv(mmc);
+	ret = mmc_of_parse(mmc);
+	if (ret)
+		goto host_free;
+
+	if (dev->of_node) {
+		host->src_clk = devm_clk_get(&pdev->dev, "phytium_mci_clk");
+		if (IS_ERR(host->src_clk)) {
+			ret = PTR_ERR(host->src_clk);
+			goto host_free;
+		}
+
+		host->clk_rate = clk_get_rate(host->src_clk);
+	} else if (has_acpi_companion(dev)) {
+		match = acpi_match_device(dev->driver->acpi_match_table, dev);
+		if (!match) {
+			dev_err(dev, "Error ACPI match data is missing\n");
+			return -ENODEV;
+		}
+		host->clk_rate = 1200000000;
+	}
+
+	host->is_use_dma = 1;
+	host->is_device_x100 = 0;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	host->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(host->base)) {
+		ret = PTR_ERR(host->base);
+		goto host_free;
+	}
+
+	host->irq = platform_get_irq(pdev, 0);
+
+	if (host->irq < 0) {
+		ret = -EINVAL;
+		goto host_free;
+	}
+	host->irq_flags = IRQF_SHARED;
+	dev_dbg(&pdev->dev, "%s %d:irq:%d\n", __func__, __LINE__, host->irq);
+	host->dev = &pdev->dev;
+	host->caps = mci_caps;
+	host->mmc = mmc;
+	ret = phytium_mci_common_probe(host);
+	if (ret == MCI_REALEASE_MEM) {
+		ret = -ENOMEM;
+		goto release_mem;
+	} else if (ret) {
+		goto release;
+	}
+	platform_set_drvdata(pdev, mmc);
+	dev_info(&pdev->dev, "%s %d: probe phytium mci successful.\n", __func__, __LINE__);
+	return 0;
+
+release:
+	phytium_mci_deinit_hw(host);
+release_mem:
+	if (host->dma.adma_table) {
+		dma_free_coherent(&pdev->dev,
+				  MAX_BD_NUM * sizeof(struct phytium_adma2_64_desc),
+				  host->dma.adma_table, host->dma.adma_addr);
+	}
+host_free:
+	mmc_free_host(mmc);
+	return ret;
+}
+
+static int phytium_mci_remove(struct platform_device *pdev)
+{
+	struct mmc_host *mmc;
+	struct phytium_mci_host *host;
+
+	mmc = platform_get_drvdata(pdev);
+	if (!mmc) {
+		dev_info(&pdev->dev, "%s %d: mmc is null.\n", __func__, __LINE__);
+		return -1;
+	}
+	host = mmc_priv(mmc);
+	if (!host) {
+		dev_info(&pdev->dev, "%s %d: host is null.\n", __func__, __LINE__);
+		mmc_remove_host(mmc);
+		mmc_free_host(mmc);
+		return -1;
+	}
+	del_timer(&host->hotplug_timer);
+	del_timer_sync(&host->timeout_timer);
+	mmc_remove_host(host->mmc);
+
+	if (host->dma.adma_table) {
+		dma_free_coherent(&pdev->dev,
+				  MAX_BD_NUM * sizeof(struct phytium_adma2_64_desc),
+				  host->dma.adma_table, host->dma.adma_addr);
+	}
+	phytium_mci_deinit_hw(host);
+	mmc_free_host(mmc);
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+static const struct of_device_id phytium_mci_of_ids[] = {
+	{   .compatible =  "phytium,mci", },
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, phytium_mci_of_ids);
+
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id phytium_mci_acpi_ids[] = {
+        { .id = "PHYT0017" },
+        { }
+};
+
+MODULE_DEVICE_TABLE(acpi, phytium_mci_acpi_ids);
+#else
+#define phytium_mci_acpi_ids NULL
+#endif
+
+static struct platform_driver phytium_mci_driver = {
+	.probe = phytium_mci_probe,
+	.remove = phytium_mci_remove,
+	.driver = {
+		.name = "phytium-mci-platform",
+		.of_match_table = phytium_mci_of_ids,
+		.acpi_match_table = phytium_mci_acpi_ids,
+		.pm = &phytium_mci_dev_pm_ops,
+	},
+};
+
+module_platform_driver(phytium_mci_driver);
+
+MODULE_DESCRIPTION("Phytium Multimedia Card Interface driver");
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Cheng Quan <chengquan@phytium.com.cn>");
diff --git a/drivers/mmc/host/phytium-mci.c b/drivers/mmc/host/phytium-mci.c
new file mode 100644
index 000000000000..cedc39cc1ab4
--- /dev/null
+++ b/drivers/mmc/host/phytium-mci.c
@@ -0,0 +1,1561 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Driver for Phytium Multimedia Card Interface
+ *
+ * Copyright (c) 2021-2024 Phytium Technology Co., Ltd.
+ */
+
+#include <linux/moduleparam.h>
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/ioport.h>
+#include <linux/irq.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+#include <linux/of_gpio.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/acpi.h>
+#include <linux/timer.h>
+#include <linux/swab.h>
+#include <linux/pci.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/core.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/sd.h>
+#include <linux/mmc/sdio.h>
+#include <linux/delay.h>
+#include "phytium-mci.h"
+
+static const u32 cmd_ints_mask = MCI_INT_MASK_RE | MCI_INT_MASK_CMD | MCI_INT_MASK_RCRC |
+				 MCI_INT_MASK_RTO | MCI_INT_MASK_HTO | MCI_RAW_INTS_HLE;
+
+static const u32 data_ints_mask = MCI_INT_MASK_DTO | MCI_INT_MASK_DCRC | MCI_INT_MASK_DRTO |
+				  MCI_INT_MASK_SBE_BCI;
+static const u32 cmd_err_ints_mask = MCI_INT_MASK_RTO | MCI_INT_MASK_RCRC | MCI_INT_MASK_RE |
+				     MCI_INT_MASK_DCRC | MCI_INT_MASK_DRTO |
+				     MCI_MASKED_INTS_SBE_BCI;
+
+static const u32 dmac_ints_mask = MCI_DMAC_INT_ENA_FBE | MCI_DMAC_INT_ENA_DU |
+				  MCI_DMAC_INT_ENA_NIS | MCI_DMAC_INT_ENA_AIS;
+static const u32 dmac_err_ints_mask = MCI_DMAC_INT_ENA_FBE | MCI_DMAC_INT_ENA_DU |
+				      MCI_DMAC_INT_ENA_AIS;
+
+static void phytium_mci_cmd_next(struct phytium_mci_host *host,
+				  struct mmc_request *mrq,
+				  struct mmc_command *cmd);
+static void phytium_mci_adma_reset(struct phytium_mci_host *host);
+static void phytium_mci_send_cmd(struct phytium_mci_host *host, u32 cmd, u32 arg);
+static bool phytium_mci_data_xfer_done(struct phytium_mci_host *host, u32 events,
+					struct mmc_request *mrq, struct mmc_data *data);
+static void phytium_mci_init_adma_table(struct phytium_mci_host *host,
+					 struct phytium_mci_dma *dma);
+static void phytium_mci_init_hw(struct phytium_mci_host *host);
+static int phytium_mci_get_cd(struct mmc_host *mmc);
+static int phytium_mci_err_irq(struct phytium_mci_host *host, u32 dmac_events, u32 events);
+
+static void sdr_set_bits(void __iomem *reg, u32 bs)
+{
+	u32 val = readl(reg);
+
+	val |= bs;
+	writel(val, reg);
+}
+
+static void sdr_clr_bits(void __iomem *reg, u32 bs)
+{
+	u32 val = readl(reg);
+
+	val &= ~bs;
+	writel(val, reg);
+}
+
+static void phytium_mci_reset_hw(struct phytium_mci_host *host)
+{
+	sdr_set_bits(host->base + MCI_CNTRL, MCI_CNTRL_FIFO_RESET | MCI_CNTRL_DMA_RESET);
+
+	while (readl(host->base + MCI_CNTRL) & (MCI_CNTRL_FIFO_RESET | MCI_CNTRL_DMA_RESET))
+		cpu_relax();
+	phytium_mci_send_cmd(host, MCI_CMD_UPD_CLK, 0);
+}
+
+static void phytium_mci_update_external_clk(struct phytium_mci_host *host, u32 uhs_reg_value)
+{
+	writel(0, host->base + MCI_UHS_REG_EXT);
+	writel(uhs_reg_value, host->base + MCI_UHS_REG_EXT);
+	while (!(readl(host->base + MCI_CCLK_RDY) & 0x1))
+		cpu_relax();
+}
+
+static void phytium_mci_prepare_data(struct phytium_mci_host *host,
+				      struct mmc_request *mrq)
+{
+	struct mmc_data *data = mrq->data;
+
+	if (!(data->host_cookie & MCI_PREPARE_FLAG)) {
+		data->host_cookie |= MCI_PREPARE_FLAG;
+		data->sg_count = dma_map_sg(host->dev, data->sg, data->sg_len,
+					    mmc_get_dma_dir(data));
+	}
+}
+
+static void phytium_mci_unprepare_data(struct phytium_mci_host *host,
+					struct mmc_request *mrq)
+{
+	struct mmc_data *data = mrq->data;
+
+	if (data->host_cookie & MCI_ASYNC_FLAG)
+		return;
+
+	if (data->host_cookie & MCI_PREPARE_FLAG) {
+		dma_unmap_sg(host->dev, data->sg, data->sg_len, mmc_get_dma_dir(data));
+		data->host_cookie &= ~MCI_PREPARE_FLAG;
+	}
+}
+
+static void phytium_mci_send_cmd(struct phytium_mci_host *host, u32 cmd, u32 arg)
+{
+	int rc;
+	u32 data;
+
+	writel(arg, host->base + MCI_CMDARG);
+	wmb(); /* drain writebuffer */
+
+	rc = readl_relaxed_poll_timeout(host->base + MCI_STATUS,
+					 data,
+					 !(data & MCI_STATUS_CARD_BUSY),
+					 0, 100 * 1000);
+	if (rc == -ETIMEDOUT)
+		pr_debug("%s %d, timeout mci_status: 0x%08x\n", __func__, __LINE__, data);
+
+	writel(MCI_CMD_START | cmd, host->base + MCI_CMD);
+
+	rc = readl_relaxed_poll_timeout(host->base + MCI_CMD,
+					 data,
+					 !(data & MCI_CMD_START),
+					 0, 100 * 1000);
+	if (rc == -ETIMEDOUT)
+		pr_debug("%s %d, timeout mci_cmd: 0x%08x\n", __func__, __LINE__, data);
+}
+
+static void phytium_mci_update_cmd11(struct phytium_mci_host *host, u32 cmd)
+{
+	writel(MCI_CMD_START | cmd, host->base + MCI_CMD);
+
+	while (readl(host->base + MCI_CMD) & MCI_CMD_START)
+		cpu_relax();
+}
+
+static void phytium_mci_set_clk(struct phytium_mci_host *host, struct mmc_ios *ios)
+{
+	u32 div = 0xff, drv = 0, sample = 0;
+	unsigned long clk_rate;
+	u32 mci_cmd_bits = MCI_CMD_UPD_CLK;
+	u32 cmd_reg;
+	u32 cur_cmd_index;
+	u32 first_uhs_div, tmp_ext_reg;
+
+	cmd_reg = readl(host->base + MCI_CMD);
+	cur_cmd_index = cmd_reg & 0x3F;
+
+	if (cur_cmd_index == SD_SWITCH_VOLTAGE)
+		mci_cmd_bits |= MCI_CMD_VOLT_SWITCH;
+	if (ios->clock) {
+		if (host->current_ios_clk == ios->clock)
+			return;
+
+		dev_dbg(host->dev, "will change clock, host->clk_rate: %ld, ios->clock: %d\n",
+			host->clk_rate, ios->clock);
+
+		if (ios->clock >= 25000000)
+			tmp_ext_reg = 0x202;
+		else if (ios->clock == 400000)
+			tmp_ext_reg = 0x502;
+		else
+			tmp_ext_reg = 0x302;
+
+		phytium_mci_update_external_clk(host, tmp_ext_reg);
+		sdr_clr_bits(host->base + MCI_CLKENA, MCI_CLKENA_CCLK_ENABLE);
+
+		if (cur_cmd_index == SD_SWITCH_VOLTAGE)
+			phytium_mci_update_cmd11(host, mci_cmd_bits | cmd_reg);
+		else
+			phytium_mci_send_cmd(host, mci_cmd_bits, 0);
+
+		clk_rate = host->clk_rate;
+		first_uhs_div = 1 + ((tmp_ext_reg >> 8)&0xFF);
+		div = clk_rate / (2 * first_uhs_div * ios->clock);
+		if (div > 2) {
+			sample = div / 2 + 1;
+			drv = sample - 1;
+			writel((sample << 16) | (drv << 8) | (div & 0xff),
+			       host->base + MCI_CLKDIV);
+		} else if (div == 2) {
+			drv = 0;
+			sample = 1;
+			writel((drv << 8) | (sample << 16) | (div & 0xff),
+			       host->base + MCI_CLKDIV);
+		}
+
+		dev_dbg(host->dev, "UHS_REG_EXT ext: %x, CLKDIV: %x\n",
+			readl(host->base + MCI_UHS_REG_EXT), readl(host->base + MCI_CLKDIV));
+
+		sdr_set_bits(host->base + MCI_CLKENA, MCI_CLKENA_CCLK_ENABLE);
+
+		if (cur_cmd_index == SD_SWITCH_VOLTAGE)
+			phytium_mci_update_cmd11(host, mci_cmd_bits | cmd_reg);
+		else
+			phytium_mci_send_cmd(host, mci_cmd_bits, 0);
+
+		host->current_ios_clk = ios->clock;
+
+		dev_dbg(host->dev, "host->clk_rate: %ld, ios->clock: %d\n",
+			host->clk_rate, ios->clock);
+	} else {
+		host->current_ios_clk = 0;
+		sdr_clr_bits(host->base + MCI_CLKENA, MCI_CLKENA_CCLK_ENABLE);
+
+		if (cur_cmd_index == SD_SWITCH_VOLTAGE)
+			phytium_mci_update_cmd11(host, mci_cmd_bits | cmd_reg);
+		else
+			phytium_mci_send_cmd(host, mci_cmd_bits, 0);
+
+		sdr_clr_bits(host->base + MCI_UHS_REG_EXT, MCI_EXT_CLK_ENABLE);
+		dev_dbg(host->dev, "host->clk_rate: %ld, ios->clock: %d\n",
+			host->clk_rate, ios->clock);
+	}
+}
+
+static inline u32
+phytium_mci_cmd_find_resp(struct phytium_mci_host *host,
+			  struct mmc_request *mrq,
+			  struct mmc_command *cmd)
+{
+	u32 resp;
+
+	switch (mmc_resp_type(cmd)) {
+	case MMC_RSP_R1:
+	case MMC_RSP_R1B:
+		resp = 0x5;
+		break;
+
+	case MMC_RSP_R2:
+		resp = 0x7;
+		break;
+
+	case MMC_RSP_R3:
+		resp = 0x1;
+		break;
+
+	case MMC_RSP_NONE:
+	default:
+		resp = 0x0;
+		break;
+	}
+
+	return resp;
+}
+
+static inline
+u32 phytium_mci_cmd_prepare_raw_cmd(struct phytium_mci_host *host,
+				     struct mmc_request *mrq,
+				     struct mmc_command *cmd)
+{
+	u32 opcode = cmd->opcode;
+	u32 resp = phytium_mci_cmd_find_resp(host, mrq, cmd);
+	u32 rawcmd = ((opcode & 0x3f) | ((resp & 0x7) << 6));
+
+	if (opcode == MMC_GO_INACTIVE_STATE ||
+	    (opcode == SD_IO_RW_DIRECT && ((cmd->arg >> 9) & 0x1FFFF) == SDIO_CCCR_ABORT))
+		rawcmd |= (0x1 << 14);
+	else if (opcode == SD_SWITCH_VOLTAGE)
+		rawcmd |= (0x1 << 28);
+
+	if (test_and_clear_bit(MCI_CARD_NEED_INIT, &host->flags))
+		rawcmd |= (0x1 << 15);
+
+	if (cmd->data) {
+		struct mmc_data *data = cmd->data;
+
+		rawcmd |= (0x1 << 9);
+
+		if (data->flags & MMC_DATA_WRITE)
+			rawcmd |= (0x1 << 10);
+	}
+
+	return (rawcmd | (0x1 << 31));
+}
+
+static inline void
+phytium_mci_adma_write_desc(struct phytium_mci_host *host,
+			     struct phytium_adma2_64_desc *desc,
+			     dma_addr_t addr, u32 len, u32 attribute)
+{
+	desc->attribute = attribute;
+	desc->len = len;
+	desc->addr_lo = lower_32_bits(addr);
+	desc->addr_hi = upper_32_bits(addr);
+	dev_dbg(host->dev, "%s %d:addr_lo:0x%x ddr_hi:0x%x\n", __func__,
+		__LINE__,  desc->addr_lo, desc->addr_hi);
+
+	if ((attribute == 0x80000004) || (attribute == 0x8000000c)) {
+		desc->desc_lo = 0;
+		desc->desc_hi = 0;
+	}
+}
+
+static void
+phytium_mci_data_sg_write_2_admc_table(struct phytium_mci_host *host, struct mmc_data *data)
+{
+	struct phytium_adma2_64_desc *desc;
+	u32 dma_len, i;
+	dma_addr_t dma_address;
+	struct scatterlist *sg;
+
+	phytium_mci_init_adma_table(host, &host->dma);
+
+	desc = host->dma.adma_table;
+	for_each_sg(data->sg, sg, data->sg_count, i) {
+		dma_address = sg_dma_address(sg);
+		dma_len = sg_dma_len(sg);
+
+		if (i == 0) {
+			if (sg_is_last(sg) || (data->sg_count == 1 && dma_len == SD_BLOCK_SIZE))
+				phytium_mci_adma_write_desc(host, desc, dma_address,
+							     dma_len, 0x8000000c);
+			else
+				phytium_mci_adma_write_desc(host, desc, dma_address,
+							     dma_len, 0x8000001a);
+		} else if (sg_is_last(sg)) {
+			phytium_mci_adma_write_desc(host, desc, dma_address,
+						     dma_len, 0x80000004);
+		} else {
+			phytium_mci_adma_write_desc(host, desc, dma_address,
+						     dma_len, 0x80000012);
+		}
+
+		desc++;
+	}
+}
+
+static void
+phytium_mci_data_sg_write_2_fifo(struct phytium_mci_host *host, struct mmc_data *data)
+{
+	struct scatterlist *sg;
+	u32 dma_len, i, j;
+	u32 *virt_addr;
+
+	if (mmc_get_dma_dir(data) == DMA_TO_DEVICE) {
+		writel(0x1<<10, host->base + MCI_CMD);
+		for_each_sg(data->sg, sg, data->sg_count, i) {
+			dma_len = sg_dma_len(sg);
+			virt_addr = sg_virt(data->sg);
+			for (j = 0; j < (dma_len / 4); j++) {
+				writel(*virt_addr, host->base + MCI_DATA);
+				virt_addr++;
+			}
+		}
+	}
+}
+
+static void phytium_mci_restart_clk(struct phytium_mci_host *host)
+{
+	u32 clk_div, uhs;
+
+	while (readl(host->base + MCI_CMD) & MCI_CMD_START)
+		cpu_relax();
+	sdr_clr_bits(host->base + MCI_CLKENA, MCI_CLKENA_CCLK_ENABLE);
+	clk_div = readl(host->base + MCI_CLKDIV);
+	uhs = readl(host->base + MCI_UHS_REG_EXT);
+	writel(0, host->base + MCI_UHS_REG_EXT);
+	writel(uhs, host->base + MCI_UHS_REG_EXT);
+	while (!(readl(host->base + MCI_CCLK_RDY) & 0x1))
+		cpu_relax();
+
+	writel(clk_div, host->base + MCI_CLKDIV);
+	sdr_set_bits(host->base + MCI_CLKENA, MCI_CLKENA_CCLK_ENABLE);
+	writel(MCI_CMD_START | MCI_CMD_UPD_CLK, host->base + MCI_CMD);
+	while (readl(host->base + MCI_CMD) & MCI_CMD_START)
+		cpu_relax();
+}
+
+static int
+phytim_mci_start_multiple_write(struct phytium_mci_host *host,
+				struct mmc_request *mrq, u32 cnts, u32 offset)
+{
+	u32 rawcmd, cmd_status;
+	struct mmc_command *cmd = mrq->cmd;
+	u32 *rsp = cmd->resp;
+	unsigned long deadline_time;
+
+	if (!(host->mmc->caps & MMC_CAP_NONREMOVABLE) && readl(host->base + MCI_CARD_DETECT))
+		return -ESHUTDOWN;
+
+	while ((readl(host->base + MCI_STATUS) & (MCI_STATUS_CARD_BUSY)))
+		cpu_relax();
+
+	writel(0xffffe, host->base + MCI_RAW_INTS);
+	rawcmd = phytium_mci_cmd_prepare_raw_cmd(host, mrq, cmd);
+	writel(mrq->data->blksz, host->base + MCI_BLKSIZ);
+	writel(cnts * mrq->data->blksz, host->base + MCI_BYTCNT);
+	writel(cmd->arg + offset, host->base + MCI_CMDARG);
+	writel(rawcmd, host->base + MCI_CMD);
+	deadline_time = jiffies + msecs_to_jiffies(200);
+
+	cmd_status = readl(host->base + MCI_RAW_INTS);
+	while (!(cmd_status & MCI_MASKED_INTS_CMD)) {
+		if (!(host->mmc->caps & MMC_CAP_NONREMOVABLE) &&
+		    readl(host->base + MCI_CARD_DETECT))
+			return -ESHUTDOWN;
+
+		cmd_status = readl(host->base + MCI_RAW_INTS);
+		if (cmd_err_ints_mask & cmd_status)
+			return -ESHUTDOWN;
+
+		if (cmd_status & MCI_MASKED_INTS_CMD)
+			break;
+
+		if (time_after(jiffies, deadline_time))
+			return -ESHUTDOWN;
+	}
+
+	if (cmd_status & MCI_MASKED_INTS_CMD) {
+		if (cmd->flags & MMC_RSP_136) {
+			rsp[3] = readl(host->base + MCI_RESP0);
+			rsp[2] = readl(host->base + MCI_RESP1);
+			rsp[1] = readl(host->base + MCI_RESP2);
+			rsp[0] = readl(host->base + MCI_RESP3);
+		} else {
+			rsp[0] = readl(host->base + MCI_RESP0);
+		}
+	}
+	deadline_time = jiffies + msecs_to_jiffies(1000);
+	while (!(cmd_status & MCI_MASKED_INTS_DTO)) {
+		if (!(host->mmc->caps & MMC_CAP_NONREMOVABLE) &&
+		    readl(host->base + MCI_CARD_DETECT))
+			return -ESHUTDOWN;
+		cmd_status = readl(host->base + MCI_RAW_INTS);
+		if (cmd_err_ints_mask & cmd_status)
+			return -ESHUTDOWN;
+		if (cmd_status & MCI_MASKED_INTS_DTO)
+			return 0;
+		if (time_after(jiffies, deadline_time))
+			return -ESHUTDOWN;
+	}
+	return 0;
+}
+
+static int
+phytium_mci_start_sbc_stop_cmd(struct phytium_mci_host *host, struct mmc_request *mrq,
+			       struct mmc_command *cmd, u32 arg)
+{
+	u32 rawcmd, cmd_status;
+	u32 *rsp = cmd->resp;
+	unsigned long deadline_time;
+
+	writel(0xffffe, host->base + MCI_RAW_INTS);
+
+	while ((readl(host->base + MCI_STATUS) & (MCI_STATUS_CARD_BUSY)))
+		cpu_relax();
+
+	rawcmd = phytium_mci_cmd_prepare_raw_cmd(host, mrq, cmd);
+	writel(arg, host->base + MCI_CMDARG);
+	writel(rawcmd, host->base + MCI_CMD);
+
+	deadline_time = jiffies + msecs_to_jiffies(200);
+	cmd_status = readl(host->base + MCI_RAW_INTS);
+	while (!(cmd_status & MCI_MASKED_INTS_CMD)) {
+		if (!(host->mmc->caps & MMC_CAP_NONREMOVABLE) &&
+		    readl(host->base + MCI_CARD_DETECT))
+			return -ENOMEDIUM;
+
+		cmd_status = readl(host->base + MCI_RAW_INTS);
+		if (cmd_err_ints_mask & cmd_status)
+			return -ETIMEDOUT;
+
+		if (cmd_status & MCI_MASKED_INTS_CMD)
+			break;
+
+		if (time_after(jiffies, deadline_time))
+			return -ETIMEDOUT;
+	}
+
+	if (cmd_status & MCI_MASKED_INTS_CMD) {
+		if (cmd->flags & MMC_RSP_136) {
+			rsp[3] = readl(host->base + MCI_RESP0);
+			rsp[2] = readl(host->base + MCI_RESP1);
+			rsp[1] = readl(host->base + MCI_RESP2);
+			rsp[0] = readl(host->base + MCI_RESP3);
+		} else {
+			rsp[0] = readl(host->base + MCI_RESP0);
+		}
+	}
+
+	if (cmd_err_ints_mask & cmd_status)
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+static void
+phytium_mci_start_write_multiple_non_dma(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct phytium_mci_host *host = mmc_priv(mmc);
+	struct mmc_data *data = mrq->data;
+	u32 write_cnts, last_cnts;
+	u32 i, j, k, send_cnt_one_sg, block_offset;
+	int ret = 0, dma_len;
+	struct scatterlist *sg;
+	u32 *virt_addr = NULL;
+
+	write_cnts = data->blocks / 4;
+	(data->blocks % 4) ? write_cnts++ : write_cnts;
+	last_cnts = data->blocks % 4;
+	if (!(host->mmc->caps & MMC_CAP_NONREMOVABLE) && readl(host->base + MCI_CARD_DETECT)) {
+		ret = -ENOMEDIUM;
+		goto write_err;
+	}
+
+	dev_dbg(host->dev, "%s: cmd:%d, block counts:%d\n",
+		__func__, mrq->cmd->opcode, data->blocks);
+
+	sdr_clr_bits(host->base + MCI_CNTRL, MCI_CNTRL_USE_INTERNAL_DMAC);
+	sdr_set_bits(host->base + MCI_CNTRL, MCI_CNTRL_FIFO_RESET);
+	while (readl(host->base + MCI_CNTRL) & MCI_CNTRL_FIFO_RESET)
+		cpu_relax();
+	sdr_clr_bits(host->base + MCI_BUS_MODE, MCI_BUS_MODE_DE);
+
+	if (mmc_get_dma_dir(data) == DMA_TO_DEVICE) {
+		block_offset = 0;
+		for_each_sg(data->sg, sg, data->sg_count, i) {
+			/* Each SG data transfor starts */
+			dma_len = sg_dma_len(sg);
+			send_cnt_one_sg = (dma_len / MCI_MAX_FIFO_CNT) + 1;
+			virt_addr = sg_virt(sg);
+			for (k = 0; k < send_cnt_one_sg; k++) {
+				if (dma_len && dma_len >= MCI_MAX_FIFO_CNT) {
+					/*first write sbc cmd*/
+					ret = phytium_mci_start_sbc_stop_cmd(host, mrq,
+									     mrq->sbc, 4);
+					if (ret)
+						goto write_err;
+					writel(0x1 << 10, host->base + MCI_CMD);
+					for (j = 0; j < (MCI_MAX_FIFO_CNT / 4); j++) {
+						writel(*virt_addr, host->base + MCI_DATA);
+						virt_addr++;
+					}
+
+					/*second write cmd25 here*/
+					ret = phytim_mci_start_multiple_write(host, mrq, 4,
+									      block_offset);
+					if (ret)
+						goto write_err;
+					block_offset += 4;
+					dma_len -= MCI_MAX_FIFO_CNT;
+				} else if (dma_len > 0) {
+					/*first write sbc cmd*/
+					last_cnts = dma_len / 512;
+					ret = phytium_mci_start_sbc_stop_cmd(host, mrq, mrq->sbc,
+									     last_cnts);
+					if (ret)
+						goto write_err;
+					writel(0x1 << 10, host->base + MCI_CMD);
+					for (j = 0; j < (dma_len / 4); j++) {
+						writel(*virt_addr, host->base + MCI_DATA);
+						virt_addr++;
+					}
+					/*second write cmd25 here*/
+					ret = phytim_mci_start_multiple_write(host, mrq, last_cnts,
+									      block_offset);
+					if (ret)
+						goto write_err;
+					block_offset += last_cnts;
+					dma_len = 0;
+				} else {
+					dev_dbg(host->dev, "%s: sg %d end\n", __func__, i);
+					break;
+				}
+			}
+		}
+	}
+
+write_err:
+	host->data = NULL;
+	host->cmd = NULL;
+	host->mrq = NULL;
+	writel(0xffffe, host->base + MCI_RAW_INTS);
+	if (ret) {
+		data->bytes_xfered = 0;
+		if (ret == -ESHUTDOWN) {
+			sdr_set_bits(host->base + MCI_CNTRL, MCI_CNTRL_FIFO_RESET);
+			while (readl(host->base + MCI_CNTRL) & MCI_CNTRL_FIFO_RESET)
+				cpu_relax();
+
+			sdr_set_bits(host->base + MCI_CNTRL, MCI_CNTRL_CONTROLLER_RESET);
+			while (readl(host->base + MCI_STATUS) & MCI_STATUS_CARD_BUSY)
+				sdr_set_bits(host->base + MCI_CNTRL, MCI_CNTRL_CONTROLLER_RESET);
+			phytium_mci_restart_clk(host);
+			phytium_mci_start_sbc_stop_cmd(host, mrq, mrq->stop, mrq->stop->arg);
+		}
+		data->error = -ETIMEDOUT;
+		mrq->cmd->error = -ETIMEDOUT;
+		mmc_request_done(host->mmc, mrq);
+		return;
+	}
+	data->bytes_xfered = data->blocks * data->blksz;
+	mmc_request_done(host->mmc, mrq);
+}
+
+static void
+phytium_mci_start_data(struct phytium_mci_host *host, struct mmc_request *mrq,
+			struct mmc_command *cmd, struct mmc_data *data)
+{
+	bool read;
+	u32 rawcmd;
+	unsigned long flags;
+
+
+	WARN_ON(host->cmd);
+	host->cmd = cmd;
+	cmd->error = 0;
+	WARN_ON(host->data);
+	host->data = data;
+	read = data->flags & MMC_DATA_READ;
+
+	if (!(host->mmc->caps & MMC_CAP_NONREMOVABLE) && readl(host->base + MCI_CARD_DETECT)) {
+		phytium_mci_err_irq(host, 0, MCI_INT_MASK_RTO);
+		return;
+	}
+	/* clear interrupts */
+	writel(0xffffe, host->base + MCI_RAW_INTS);
+
+	sdr_set_bits(host->base + MCI_CNTRL, MCI_CNTRL_FIFO_RESET | MCI_CNTRL_DMA_RESET);
+
+	while (readl(host->base + MCI_CNTRL) & (MCI_CNTRL_FIFO_RESET | MCI_CNTRL_DMA_RESET))
+		cpu_relax();
+
+	if (host->adtc_type == COMMOM_ADTC)
+		sdr_clr_bits(host->base + MCI_CNTRL, MCI_CNTRL_USE_INTERNAL_DMAC);
+	else
+		sdr_set_bits(host->base + MCI_CNTRL, MCI_CNTRL_USE_INTERNAL_DMAC);
+	wmb(); /* drain writebuffer */
+	sdr_clr_bits(host->base + MCI_CNTRL, MCI_CNTRL_INT_ENABLE);
+
+	rawcmd = phytium_mci_cmd_prepare_raw_cmd(host, mrq, cmd);
+	if (host->is_use_dma && host->adtc_type == BLOCK_RW_ADTC)
+		phytium_mci_data_sg_write_2_admc_table(host, data);
+	else
+		phytium_mci_data_sg_write_2_fifo(host, data);
+
+	spin_lock_irqsave(&host->lock, flags);
+	mod_timer(&host->timeout_timer,
+		  jiffies + msecs_to_jiffies(MMC_REQ_TIMEOUT_MS));
+	sdr_set_bits(host->base + MCI_INT_MASK, cmd_ints_mask | data_ints_mask);
+	if (host->is_use_dma && host->adtc_type == BLOCK_RW_ADTC) {
+		sdr_set_bits(host->base + MCI_DMAC_INT_ENA, dmac_ints_mask);
+		/* Enable the IDMAC */
+		sdr_set_bits(host->base + MCI_BUS_MODE, MCI_BUS_MODE_DE);
+		writel((u32)host->dma.adma_addr, host->base + MCI_DESC_LIST_ADDRL);
+		writel((u32)(host->dma.adma_addr >> 32), host->base + MCI_DESC_LIST_ADDRH);
+	}
+	writel(mrq->data->blksz, host->base + MCI_BLKSIZ);
+	writel(mrq->data->blocks * mrq->data->blksz, host->base + MCI_BYTCNT);
+	sdr_set_bits(host->base + MCI_CNTRL, MCI_CNTRL_INT_ENABLE);
+	writel(cmd->arg, host->base + MCI_CMDARG);
+	wmb(); /* drain writebuffer */
+	writel(rawcmd, host->base + MCI_CMD);
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
+static void phytium_mci_track_cmd_data(struct phytium_mci_host *host,
+					struct mmc_command *cmd,
+					struct mmc_data *data)
+{
+	if (host->error)
+		dev_dbg(host->dev, "%s: cmd=%d arg=%08X; host->error=0x%08X\n",
+			__func__, cmd->opcode, cmd->arg, host->error);
+}
+
+static void phytium_mci_request_done(struct phytium_mci_host *host, struct mmc_request *mrq)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+	del_timer(&host->timeout_timer);
+	host->mrq = NULL;
+	if (host->cmd)
+		host->cmd = NULL;
+	spin_unlock_irqrestore(&host->lock, flags);
+	phytium_mci_track_cmd_data(host, mrq->cmd, mrq->data);
+
+	if (mrq->data)
+		phytium_mci_unprepare_data(host, mrq);
+
+	mmc_request_done(host->mmc, mrq);
+}
+
+static bool phytium_mci_cmd_done(struct phytium_mci_host *host, int events,
+				 struct mmc_request *mrq, struct mmc_command *cmd)
+{
+	bool done = false;
+	unsigned long flags;
+	u32 *rsp = cmd->resp;
+
+	if (!(events & (MCI_RAW_INTS_RCRC | MCI_RAW_INTS_RE | MCI_RAW_INTS_CMD |
+	      MCI_RAW_INTS_RTO | MCI_INT_MASK_HTO))) {
+		dev_err(host->dev, "No interrupt generation:h%x\n", events);
+		return done;
+	}
+
+	spin_lock_irqsave(&host->lock, flags);
+	done = !host->cmd;
+	host->cmd = NULL;
+	if (done) {
+		spin_unlock_irqrestore(&host->lock, flags);
+		return true;
+	}
+	sdr_clr_bits(host->base + MCI_INT_MASK, cmd_ints_mask);
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	if (cmd->flags & MMC_RSP_PRESENT) {
+		if (cmd->flags & MMC_RSP_136) {
+			rsp[3] = readl(host->base + MCI_RESP0);
+			rsp[2] = readl(host->base + MCI_RESP1);
+			rsp[1] = readl(host->base + MCI_RESP2);
+			rsp[0] = readl(host->base + MCI_RESP3);
+		} else {
+			/*
+			 * Sometimes get ACMD41 cmd done irq but the respose index still the APP_CMD,
+			 * so polling the mci status entill the respose index change.
+			 */
+			if (cmd->opcode == SD_APP_OP_COND) {
+				int polling_cnt = 20;
+				while (MMC_APP_CMD == MCI_STATUS_RESPOSE_INDEX(readl(host->base + MCI_STATUS))) {
+					udelay(100);
+					polling_cnt --;
+					if (polling_cnt == 0) {
+						dev_info(host->dev, "hw respose index not equal cmd opcode, respose value may error\n");
+						break;
+					}
+				}
+			}
+			rsp[0] = readl(host->base + MCI_RESP0);
+		}
+
+		if (cmd->opcode == SD_SEND_RELATIVE_ADDR)
+			host->current_rca = rsp[0] & 0xFFFF0000;
+	}
+	if (!(events & (MCI_RAW_INTS_CMD | MCI_INT_MASK_HTO))) {
+		if (!(host->mmc->caps & MMC_CAP_NONREMOVABLE) && (events & MCI_RAW_INTS_RTO)
+		   && readl(host->base + MCI_CARD_DETECT)) {
+			cmd->error = -ENOMEDIUM;
+			rsp[0] = 0;
+		} else if (events & MCI_RAW_INTS_RTO ||
+		    (cmd->opcode != MMC_SEND_TUNING_BLOCK &&
+		     cmd->opcode != MMC_SEND_TUNING_BLOCK_HS200)) {
+			cmd->error = -ETIMEDOUT;
+		} else if (events & MCI_RAW_INTS_RCRC) {
+			cmd->error = -EILSEQ;
+		} else {
+			cmd->error = -ETIMEDOUT;
+		}
+	}
+	phytium_mci_cmd_next(host, mrq, cmd);
+	return true;
+}
+
+static void phytium_mci_start_command(struct phytium_mci_host *host,
+				       struct mmc_request *mrq,
+				       struct mmc_command *cmd)
+{
+	u32 rawcmd;
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+	WARN_ON(host->cmd);
+	host->cmd = cmd;
+	cmd->error = 0;
+	writel(0xffffe, host->base + MCI_RAW_INTS);
+
+	rawcmd = phytium_mci_cmd_prepare_raw_cmd(host, mrq, cmd);
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	if (!(host->mmc->caps & MMC_CAP_NONREMOVABLE) && readl(host->base + MCI_CARD_DETECT)) {
+		phytium_mci_cmd_done(host, MCI_RAW_INTS_RTO, mrq, cmd);
+		return;
+	}
+
+	spin_lock_irqsave(&host->lock, flags);
+	mod_timer(&host->timeout_timer,
+		  jiffies + msecs_to_jiffies(MMC_REQ_TIMEOUT_MS));
+	sdr_set_bits(host->base + MCI_INT_MASK, cmd_ints_mask);
+	writel(cmd->arg, host->base + MCI_CMDARG);
+	writel(rawcmd, host->base + MCI_CMD);
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
+static void
+phytium_mci_cmd_next(struct phytium_mci_host *host, struct mmc_request *mrq,
+		      struct mmc_command *cmd)
+{
+	if ((cmd->error && !(cmd->opcode == MMC_SEND_TUNING_BLOCK ||
+		cmd->opcode == MMC_SEND_TUNING_BLOCK_HS200)) ||
+		(mrq->sbc && mrq->sbc->error)) {
+		phytium_mci_request_done(host, mrq);
+	} else if (cmd == mrq->sbc) {
+		if ((mrq->cmd->opcode == MMC_READ_MULTIPLE_BLOCK) ||
+		    (mrq->cmd->opcode == MMC_WRITE_MULTIPLE_BLOCK) ||
+		    (mrq->cmd->opcode == MMC_READ_SINGLE_BLOCK) ||
+		    (mrq->cmd->opcode == MMC_WRITE_BLOCK)) {
+			dev_dbg(host->dev, "%s %d:sbc done and next cmd :%d length:%d\n",
+				__func__, __LINE__, mrq->cmd->opcode, mrq->data->sg->length);
+			phytium_mci_prepare_data(host, mrq);
+			if (host->is_use_dma)
+				host->adtc_type = BLOCK_RW_ADTC;
+			else
+				host->adtc_type = COMMOM_ADTC;
+			phytium_mci_start_data(host, mrq, mrq->cmd, mrq->data);
+		} else {
+			dev_err(host->dev, "%s %d:ERROR: cmd %d followers the SBC\n",
+				__func__, __LINE__, cmd->opcode);
+		}
+	} else if (!cmd->data) {
+		phytium_mci_request_done(host, mrq);
+	}
+}
+
+static void phytium_mci_ops_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct phytium_mci_host *host = mmc_priv(mmc);
+	u32 data;
+	int rc;
+
+	host->error = 0;
+	WARN_ON(host->mrq);
+	host->mrq = mrq;
+
+	rc = readl_relaxed_poll_timeout(host->base + MCI_STATUS,
+					 data,
+					 !(data & MCI_STATUS_CARD_BUSY),
+					 0, 500 * 1000);
+	if (rc == -ETIMEDOUT)
+		pr_debug("%s %d, timeout mci_status: 0x%08x\n", __func__, __LINE__, data);
+
+	dev_dbg(host->dev, "%s %d: cmd:%d arg:0x%x\n", __func__, __LINE__,
+		mrq->cmd->opcode, mrq->cmd->arg);
+
+	if (host->is_device_x100 && mrq->sbc && mrq->cmd->opcode == MMC_WRITE_MULTIPLE_BLOCK) {
+		phytium_mci_start_write_multiple_non_dma(mmc, mrq);
+		return;
+	}
+
+	if (mrq->sbc) {
+		phytium_mci_start_command(host, mrq, mrq->sbc);
+		return;
+	}
+	if (mrq->data) {
+		phytium_mci_prepare_data(host, mrq);
+
+		if ((mrq->data->sg->length >= 512) && host->is_use_dma &&
+			((mrq->cmd->opcode == MMC_READ_MULTIPLE_BLOCK) ||
+			(mrq->cmd->opcode == MMC_READ_SINGLE_BLOCK) ||
+			(mrq->cmd->opcode == MMC_WRITE_MULTIPLE_BLOCK) ||
+			(mrq->cmd->opcode == MMC_WRITE_BLOCK) ||
+			(mrq->cmd->opcode == SD_IO_RW_EXTENDED)))
+
+			host->adtc_type = BLOCK_RW_ADTC;
+		else
+			host->adtc_type = COMMOM_ADTC;
+
+		phytium_mci_start_data(host, mrq, mrq->cmd, mrq->data);
+		return;
+	}
+	phytium_mci_start_command(host, mrq, mrq->cmd);
+}
+
+static void phytium_mci_pre_req(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct phytium_mci_host *host = mmc_priv(mmc);
+	struct mmc_data *data = mrq->data;
+
+	if (!data)
+		return;
+
+	phytium_mci_prepare_data(host, mrq);
+	data->host_cookie |= MCI_ASYNC_FLAG;
+}
+
+static void phytium_mci_post_req(struct mmc_host *mmc, struct mmc_request *mrq,
+				  int err)
+{
+	struct phytium_mci_host *host = mmc_priv(mmc);
+	struct mmc_data *data = mrq->data;
+
+	if (!data)
+		return;
+
+	if (data->host_cookie & MCI_ASYNC_FLAG) {
+		data->host_cookie &= ~MCI_ASYNC_FLAG;
+		phytium_mci_unprepare_data(host, mrq);
+	}
+}
+
+static void phytium_mci_data_read_without_dma(struct phytium_mci_host *host,
+					      struct mmc_data *data)
+{
+	u32 length, i, data_val, dma_len, tmp = 0;
+	u32 *virt_addr;
+	unsigned long flags;
+	struct scatterlist *sg;
+
+	length = data->blocks * data->blksz;
+
+	if (mmc_get_dma_dir(data) == DMA_FROM_DEVICE) {
+		spin_lock_irqsave(&host->lock, flags);
+		if (data->host_cookie & MCI_ASYNC_FLAG) {
+			tmp = MCI_ASYNC_FLAG;
+			phytium_mci_post_req(host->mmc, data->mrq, 0);
+		} else {
+			phytium_mci_unprepare_data(host, data->mrq);
+		}
+
+		for_each_sg(data->sg, sg, data->sg_count, i) {
+			dma_len = sg_dma_len(sg);
+			virt_addr = sg_virt(data->sg);
+
+			for (i = 0; i < (dma_len / 4); i++) {
+				data_val = readl(host->base + MCI_DATA);
+				memcpy(virt_addr, &data_val, 4);
+				++virt_addr;
+			}
+		}
+
+		if (tmp & MCI_ASYNC_FLAG)
+			phytium_mci_pre_req(host->mmc, data->mrq);
+		else
+			phytium_mci_prepare_data(host, data->mrq);
+
+		spin_unlock_irqrestore(&host->lock, flags);
+	}
+	data->bytes_xfered = length;
+}
+
+static void phytium_mci_data_xfer_next(struct phytium_mci_host *host,
+					struct mmc_request *mrq,
+					struct mmc_data *data)
+{
+	if (mmc_op_multi(mrq->cmd->opcode) && mrq->stop &&
+	    (data->error || !mrq->sbc)) {
+		while ((readl(host->base + MCI_STATUS) & (MCI_STATUS_CARD_BUSY)))
+			cpu_relax();
+		phytium_mci_start_command(host, mrq, mrq->stop);
+	} else {
+		phytium_mci_request_done(host, mrq);
+	}
+}
+
+static bool phytium_mci_data_xfer_done(struct phytium_mci_host *host, u32 events,
+					struct mmc_request *mrq, struct mmc_data *data)
+{
+	unsigned long flags;
+	bool done;
+
+	unsigned int check_data = events & (MCI_RAW_INTS_DTO | MCI_RAW_INTS_RCRC |
+					    MCI_RAW_INTS_DCRC | MCI_RAW_INTS_RE |
+					    MCI_RAW_INTS_DRTO | MCI_RAW_INTS_EBE |
+					    MCI_DMAC_STATUS_AIS | MCI_DMAC_STATUS_DU |
+					    MCI_RAW_INTS_SBE_BCI | MCI_INT_MASK_RTO);
+
+	spin_lock_irqsave(&host->lock, flags);
+	done = !host->data;
+
+	if (check_data || host->data)
+		host->data = NULL;
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	if (done)
+		return true;
+	if (check_data) {
+		spin_lock_irqsave(&host->lock, flags);
+		sdr_clr_bits(host->base + MCI_DMAC_INT_ENA, dmac_ints_mask);
+		sdr_clr_bits(host->base + MCI_INT_MASK, data_ints_mask);
+		/* Stop the IDMAC running */
+		sdr_clr_bits(host->base + MCI_BUS_MODE, MCI_BUS_MODE_DE);
+		dev_dbg(host->dev, "DMA stop\n");
+		spin_unlock_irqrestore(&host->lock, flags);
+
+		if (events & MCI_RAW_INTS_DTO) {
+			if (!host->is_use_dma ||
+			    (host->is_use_dma && host->adtc_type == COMMOM_ADTC &&
+			     (mrq->cmd->flags & MMC_CMD_MASK) == MMC_CMD_ADTC))
+				phytium_mci_data_read_without_dma(host, data);
+			else
+				data->bytes_xfered = data->blocks * data->blksz;
+		} else {
+			data->bytes_xfered = 0;
+			if (!(host->mmc->caps & MMC_CAP_NONREMOVABLE)
+			    && readl(host->base + MCI_CARD_DETECT)
+			    && (events & cmd_err_ints_mask)) {
+				data->error = -ENOMEDIUM;
+				data->mrq->cmd->error =  -ENOMEDIUM;
+			} else if (events & (MCI_RAW_INTS_DCRC | MCI_RAW_INTS_EBE |
+					   MCI_RAW_INTS_SBE_BCI)) {
+				data->error = -EILSEQ;
+				host->cmd = NULL;
+			} else {
+				data->error = -ETIMEDOUT;
+				host->cmd = NULL;
+			}
+		}
+
+		phytium_mci_data_xfer_next(host, mrq, data);
+		done = true;
+	}
+	return done;
+}
+
+static int phytium_mci_card_busy(struct mmc_host *mmc)
+{
+	struct phytium_mci_host *host = mmc_priv(mmc);
+	u32 status;
+
+	status = readl(host->base + MCI_STATUS);
+
+	return !!(status & MCI_STATUS_CARD_BUSY);
+}
+
+static void __phytium_mci_enable_sdio_irq(struct phytium_mci_host *host, int enable)
+{
+	if (enable)
+		sdr_set_bits(host->base + MCI_INT_MASK, MCI_INT_MASK_SDIO);
+	else
+		sdr_clr_bits(host->base + MCI_INT_MASK, MCI_INT_MASK_SDIO);
+}
+
+static void phytium_mci_enable_sdio_irq(struct mmc_host *mmc, int enable)
+{
+	struct phytium_mci_host *host  = mmc_priv(mmc);
+
+	__phytium_mci_enable_sdio_irq(host, enable);
+}
+
+static void hotplug_timer_func(struct timer_list *t)
+{
+	struct phytium_mci_host *host;
+	u32 status;
+
+	host = from_timer(host, t, hotplug_timer);
+	if (!host)
+		return;
+
+	status = readl(host->base + MCI_CARD_DETECT);
+
+	if (status & 0x1) {
+		if (host->mmc->card) {
+			cancel_delayed_work(&host->mmc->detect);
+			mmc_detect_change(host->mmc, msecs_to_jiffies(100));
+		}
+	} else {
+		cancel_delayed_work(&host->mmc->detect);
+		mmc_detect_change(host->mmc, msecs_to_jiffies(200));
+	}
+}
+
+static void phytium_mci_request_timeout(struct timer_list *t)
+{
+	struct phytium_mci_host *host = from_timer(host, t, timeout_timer);
+
+	dev_err(host->dev, "request timeout\n");
+	if (host->mrq) {
+		dev_err(host->dev, "aborting mrq=%p cmd=%d\n",
+				host->mrq, host->mrq->cmd->opcode);
+		if (host->cmd) {
+			dev_err(host->dev, "aborting cmd=%d\n", host->cmd->opcode);
+			phytium_mci_cmd_done(host, MCI_RAW_INTS_RTO, host->mrq, host->cmd);
+		} else if (host->data) {
+			dev_err(host->dev, "abort data: cmd%d; %d blocks\n",
+					host->mrq->cmd->opcode, host->data->blocks);
+			phytium_mci_data_xfer_done(host, MCI_RAW_INTS_RTO, host->mrq,
+					host->data);
+		}
+	}
+}
+
+static int phytium_mci_err_irq(struct phytium_mci_host *host, u32 dmac_events, u32 events)
+{
+	struct mmc_request *mrq;
+	struct mmc_command *cmd;
+	struct mmc_data *data;
+
+	mrq = host->mrq;
+	cmd = host->cmd;
+	data = host->data;
+
+	if (cmd && (cmd == mrq->sbc)) {
+		phytium_mci_cmd_done(host, MCI_RAW_INTS_RTO, mrq, mrq->sbc);
+	} else if (cmd && (cmd == mrq->stop)) {
+		phytium_mci_cmd_done(host, MCI_RAW_INTS_RTO, mrq, mrq->stop);
+	} else if (data) {
+		data->error = -ETIMEDOUT;
+		if ((data->flags & MMC_DATA_READ) == MMC_DATA_READ ||
+		    (data->flags & MMC_DATA_WRITE) == MMC_DATA_WRITE)
+			phytium_mci_data_xfer_done(host, events | dmac_events, mrq, data);
+	} else if (cmd) {
+		phytium_mci_cmd_done(host, MCI_RAW_INTS_RTO, mrq, mrq->cmd);
+	}
+
+	return 0;
+}
+
+static irqreturn_t phytium_mci_irq(int irq, void *dev_id)
+{
+	struct phytium_mci_host *host = (struct phytium_mci_host *) dev_id;
+	unsigned long flags;
+	struct mmc_request *mrq;
+	struct mmc_command *cmd;
+	struct mmc_data *data;
+	u32 events, event_mask, dmac_events, dmac_evt_mask;
+
+	if (!host)
+		return IRQ_NONE;
+	writel(0, host->base + 0xfd0);
+
+	spin_lock_irqsave(&host->lock, flags);
+	events = readl(host->base + MCI_RAW_INTS);
+	dmac_events = readl(host->base + MCI_DMAC_STATUS);
+	event_mask = readl(host->base + MCI_INT_MASK);
+	dmac_evt_mask = readl(host->base + MCI_DMAC_INT_ENA);
+	if ((!events) && (!(dmac_events&0x1fff))) {
+		spin_unlock_irqrestore(&host->lock, flags);
+		return IRQ_NONE;
+	}
+	dev_dbg(host->dev, "%s:events:%x,mask:0x%x,dmac_events:%x,dmac_mask:0x%x,cmd:%d\n",
+		__func__, events, event_mask, dmac_events, dmac_evt_mask,
+		host->mrq ? host->mrq->cmd->opcode : 255);
+
+	mrq = host->mrq;
+	cmd = host->cmd;
+	data = host->data;
+
+#if 0
+	if (((events & event_mask) & MCI_RAW_INTS_SDIO) &&
+	    ((events == 0x10001) || (events == 0x10000) || (events == 0x10040))) {
+		writel(events, host->base + MCI_RAW_INTS);
+		__phytium_mci_enable_sdio_irq(host, 0);
+		sdio_signal_irq(host->mmc);
+		spin_unlock_irqrestore(&host->lock, flags);
+		goto irq_out;
+	}
+#endif
+	if ((events & event_mask) & MCI_RAW_INTS_SDIO) {
+		__phytium_mci_enable_sdio_irq(host, 0);
+	}
+
+	writel((events & event_mask), host->base + MCI_RAW_INTS);
+	writel(dmac_events, host->base + MCI_DMAC_STATUS);
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	if ((events & event_mask) & MCI_RAW_INTS_SDIO) {
+		sdio_signal_irq(host->mmc);
+	}
+
+	if (((events & event_mask) == 0) && ((dmac_evt_mask & dmac_events) == 0))
+		goto irq_out;
+
+	if (((events & event_mask) & MCI_RAW_INTS_CD) &&
+	    !(host->mmc->caps & MMC_CAP_NONREMOVABLE)) {
+		mod_timer(&host->hotplug_timer, jiffies + usecs_to_jiffies(20000));
+		dev_dbg(host->dev, "sd status changed here ! status:[%d] [%s %d]",
+			readl(host->base + MCI_CARD_DETECT), __func__, __LINE__);
+
+		if ((events & event_mask) == MCI_RAW_INTS_CD)
+			goto irq_out;
+	}
+
+	if (!mrq) {
+		if (events & MCI_RAW_INTS_HLE)
+			dev_dbg(host->dev,
+				"%s: MRQ=NULL and HW write locked, events=%08x,event_mask=%08x\n",
+				__func__, events, event_mask);
+		else
+			dev_dbg(host->dev, "%s: MRQ=NULL events:%08X evt_mask=%08X,sd_status:%d\n",
+				__func__, events, event_mask, readl(host->base + MCI_CARD_DETECT));
+		goto irq_out;
+	}
+
+	if ((dmac_events & dmac_err_ints_mask) || (events & cmd_err_ints_mask)) {
+		dev_dbg(host->dev, "ERR:events:%x,mask:0x%x,dmac_evts:%x,dmac_mask:0x%x,cmd:%d\n",
+			events, event_mask, dmac_events, dmac_evt_mask, mrq->cmd->opcode);
+		phytium_mci_err_irq(host, dmac_events & dmac_err_ints_mask,
+						    events & cmd_err_ints_mask);
+		goto irq_out;
+	}
+
+	if ((events & MCI_MASKED_INTS_DTO) && (events & MCI_MASKED_INTS_CMD)) {
+		phytium_mci_cmd_done(host, events, mrq, cmd);
+		phytium_mci_data_xfer_done(host, (events & data_ints_mask) |
+					    (dmac_events & dmac_ints_mask), mrq, data);
+	} else if (events & MCI_MASKED_INTS_CMD ||
+		  ((events & MCI_INT_MASK_HTO) && (cmd->opcode == SD_SWITCH_VOLTAGE))) {
+		phytium_mci_cmd_done(host, events, mrq, cmd);
+	} else if (events & MCI_MASKED_INTS_DTO) {
+		phytium_mci_data_xfer_done(host, (events & data_ints_mask) |
+					    (dmac_events & dmac_ints_mask), mrq, data);
+	}
+
+irq_out:
+	return IRQ_HANDLED;
+}
+
+static void phytium_mci_init_hw(struct phytium_mci_host *host)
+{
+	u32 val;
+	int uhs_reg_value = 0x502;
+
+	writel(MCI_SET_FIFOTH(0x2, 0x7, 0x100), host->base + MCI_FIFOTH);
+	writel(0x800001, host->base + MCI_CARD_THRCTL);
+	sdr_clr_bits(host->base + MCI_CLKENA, MCI_CLKENA_CCLK_ENABLE);
+	phytium_mci_update_external_clk(host, uhs_reg_value);
+
+	sdr_set_bits(host->base + MCI_PWREN, MCI_PWREN_ENABLE);
+	sdr_set_bits(host->base + MCI_CLKENA, MCI_CLKENA_CCLK_ENABLE);
+	sdr_set_bits(host->base + MCI_UHS_REG_EXT, MCI_EXT_CLK_ENABLE);
+	sdr_clr_bits(host->base + MCI_UHS_REG, MCI_UHS_REG_VOLT);
+
+	phytium_mci_reset_hw(host);
+
+	if (host->mmc->caps & MMC_CAP_NONREMOVABLE)
+		sdr_set_bits(host->base + MCI_CARD_RESET, MCI_CARD_RESET_ENABLE);
+	else
+		sdr_clr_bits(host->base + MCI_CARD_RESET, MCI_CARD_RESET_ENABLE);
+
+	writel(0, host->base + MCI_INT_MASK);
+	val = readl(host->base + MCI_RAW_INTS);
+	writel(val, host->base + MCI_RAW_INTS);
+	writel(0, host->base + MCI_DMAC_INT_ENA);
+	val = readl(host->base + MCI_DMAC_STATUS);
+	writel(val, host->base + MCI_DMAC_STATUS);
+	if (!(host->mmc->caps & MMC_CAP_NONREMOVABLE))
+		writel(MCI_INT_MASK_CD, host->base + MCI_INT_MASK);
+
+	sdr_set_bits(host->base + MCI_CNTRL, MCI_CNTRL_INT_ENABLE |
+		     MCI_CNTRL_USE_INTERNAL_DMAC);
+
+	writel(0xFFFFFFFF, host->base + MCI_TMOUT);
+	dev_info(host->dev, "init hardware done!");
+
+}
+
+void phytium_mci_deinit_hw(struct phytium_mci_host *host)
+{
+	u32 val;
+
+	sdr_clr_bits(host->base + MCI_PWREN, MCI_PWREN_ENABLE);
+	sdr_clr_bits(host->base + MCI_CLKENA, MCI_CLKENA_CCLK_ENABLE);
+	sdr_clr_bits(host->base + MCI_UHS_REG_EXT, MCI_EXT_CLK_ENABLE);
+	sdr_clr_bits(host->base + MCI_UHS_REG, MCI_UHS_REG_VOLT);
+	writel(0, host->base + MCI_INT_MASK);
+	val = readl(host->base + MCI_RAW_INTS);
+	writel(val, host->base + MCI_RAW_INTS);
+	writel(0, host->base + MCI_DMAC_INT_ENA);
+	val = readl(host->base + MCI_DMAC_STATUS);
+	writel(val, host->base + MCI_DMAC_STATUS);
+	if (!(host->mmc->caps & MMC_CAP_NONREMOVABLE))
+		writel(MCI_INT_MASK_CD, host->base + MCI_INT_MASK);
+}
+EXPORT_SYMBOL_GPL(phytium_mci_deinit_hw);
+
+static void phytium_mci_adma_reset(struct phytium_mci_host *host)
+{
+	u32 bmod = readl(host->base + MCI_BUS_MODE);
+
+	bmod |= MCI_BUS_MODE_SWR;
+	writel(bmod, host->base + MCI_BUS_MODE);
+}
+
+static void phytium_mci_init_adma_table(struct phytium_mci_host *host,
+					 struct phytium_mci_dma *dma)
+{
+	struct phytium_adma2_64_desc *adma_table = dma->adma_table;
+	dma_addr_t dma_addr;
+	int i;
+
+	memset(adma_table, 0, sizeof(struct phytium_adma2_64_desc) * MAX_BD_NUM);
+
+	for (i = 0; i < (MAX_BD_NUM - 1); i++) {
+		dma_addr = dma->adma_addr + sizeof(*adma_table) * (i + 1);
+		adma_table[i].desc_lo = lower_32_bits(dma_addr);
+		adma_table[i].desc_hi = upper_32_bits(dma_addr);
+		adma_table[i].attribute = 0;
+		adma_table[i].NON1 = 0;
+		adma_table[i].len = 0;
+		adma_table[i].NON2 = 0;
+	}
+
+	phytium_mci_adma_reset(host);
+}
+
+static void phytium_mci_set_buswidth(struct phytium_mci_host *host, u32 width)
+{
+	u32 val;
+
+	switch (width) {
+	case MMC_BUS_WIDTH_1:
+		val = MCI_BUS_1BITS;
+		break;
+
+	case MMC_BUS_WIDTH_4:
+		val = MCI_BUS_4BITS;
+		break;
+
+	case MMC_BUS_WIDTH_8:
+		val = MCI_BUS_8BITS;
+		break;
+	default:
+		val = MCI_BUS_4BITS;
+		break;
+	}
+	writel(val, host->base + MCI_CTYPE);
+	dev_dbg(host->dev, "Bus Width = %d, set value:0x%x\n", width, val);
+}
+
+static void phytium_mci_ops_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct phytium_mci_host *host = mmc_priv(mmc);
+
+	if (ios->timing == MMC_TIMING_MMC_DDR52 || ios->timing == MMC_TIMING_UHS_DDR50)
+		sdr_set_bits(host->base + MCI_UHS_REG, MCI_UHS_REG_DDR);
+	else
+		sdr_clr_bits(host->base + MCI_UHS_REG, MCI_UHS_REG_DDR);
+
+	phytium_mci_set_buswidth(host, ios->bus_width);
+
+	switch (ios->power_mode) {
+	case MMC_POWER_UP:
+		set_bit(MCI_CARD_NEED_INIT, &host->flags);
+		writel(MCI_POWER_ON, host->base + MCI_PWREN);
+		break;
+
+	case MMC_POWER_ON:
+		break;
+
+	case MMC_POWER_OFF:
+		writel(MCI_POWER_OFF, host->base + MCI_PWREN);
+		break;
+
+	default:
+		break;
+	}
+	phytium_mci_set_clk(host, ios);
+}
+
+static void phytium_mci_ack_sdio_irq(struct mmc_host *mmc)
+{
+	unsigned long flags;
+	struct phytium_mci_host *host = mmc_priv(mmc);
+
+	spin_lock_irqsave(&host->lock, flags);
+	__phytium_mci_enable_sdio_irq(host, 1);
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
+static int phytium_mci_get_cd(struct mmc_host *mmc)
+{
+	struct phytium_mci_host *host = mmc_priv(mmc);
+	u32 status;
+
+	if (mmc->caps & MMC_CAP_NONREMOVABLE)
+		return 1;
+
+	status = readl(host->base + MCI_CARD_DETECT);
+
+	if ((status & 0x1) == 0x1)
+		return 0;
+
+	return 1;
+}
+
+static int phytium_mci_ops_switch_volt(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct phytium_mci_host *host = mmc_priv(mmc);
+	unsigned int is_voltage_180 = 0;
+
+	is_voltage_180 = readl(host->base + MCI_UHS_REG);
+	if ((mmc->caps & MMC_CAP_NONREMOVABLE) && (ios->signal_voltage != MMC_SIGNAL_VOLTAGE_180))
+		return -EINVAL;
+
+	if ((ios->signal_voltage == MMC_SIGNAL_VOLTAGE_330) && (is_voltage_180 & 0x1))
+		sdr_clr_bits(host->base + MCI_UHS_REG, MCI_UHS_REG_VOLT);
+	else if ((ios->signal_voltage == MMC_SIGNAL_VOLTAGE_180) && (!(is_voltage_180 & 0x1)))
+		sdr_set_bits(host->base + MCI_UHS_REG, MCI_UHS_REG_VOLT);
+	else if (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_120)
+		return -EINVAL;
+	return 0;
+}
+
+static void phytium_mci_hw_reset(struct mmc_host *mmc)
+{
+	struct phytium_mci_host *host = mmc_priv(mmc);
+	u32 reset_flag;
+
+	if (host->is_use_dma) {
+		reset_flag = MCI_CNTRL_FIFO_RESET | MCI_CNTRL_DMA_RESET;
+		phytium_mci_adma_reset(host);
+		sdr_set_bits(host->base + MCI_CNTRL, reset_flag);
+	} else {
+		reset_flag = MCI_CNTRL_FIFO_RESET;
+		sdr_set_bits(host->base + MCI_CNTRL, reset_flag);
+	}
+
+	while (readl(host->base + MCI_CNTRL) & reset_flag)
+		cpu_relax();
+
+	sdr_clr_bits(host->base + MCI_CARD_RESET, MCI_CARD_RESET_ENABLE);
+	udelay(5);
+	sdr_set_bits(host->base + MCI_CARD_RESET, MCI_CARD_RESET_ENABLE);
+	usleep_range(200, 300);
+}
+
+#ifdef CONFIG_PM_SLEEP
+int phytium_mci_suspend(struct device *dev)
+{
+	struct mmc_host *mmc = dev_get_drvdata(dev);
+	struct phytium_mci_host *host = mmc_priv(mmc);
+
+	phytium_mci_deinit_hw(host);
+	return 0;
+}
+EXPORT_SYMBOL(phytium_mci_suspend);
+
+int phytium_mci_resume(struct device *dev)
+{
+	struct mmc_host *mmc = dev_get_drvdata(dev);
+	struct phytium_mci_host *host = mmc_priv(mmc);
+
+	phytium_mci_init_hw(host);
+	return 0;
+}
+EXPORT_SYMBOL(phytium_mci_resume);
+
+#endif
+
+#ifdef CONFIG_PM
+int phytium_mci_runtime_suspend(struct device *dev)
+{
+	struct mmc_host *mmc = dev_get_drvdata(dev);
+	struct phytium_mci_host *host = mmc_priv(mmc);
+
+	phytium_mci_deinit_hw(host);
+	return 0;
+}
+EXPORT_SYMBOL(phytium_mci_runtime_suspend);
+
+int phytium_mci_runtime_resume(struct device *dev)
+{
+	struct mmc_host *mmc = dev_get_drvdata(dev);
+	struct phytium_mci_host *host = mmc_priv(mmc);
+
+	phytium_mci_init_hw(host);
+	return 0;
+}
+EXPORT_SYMBOL(phytium_mci_runtime_resume);
+
+#endif
+
+static struct mmc_host_ops phytium_mci_ops = {
+	.post_req = phytium_mci_post_req,
+	.pre_req = phytium_mci_pre_req,
+	.request = phytium_mci_ops_request,
+	.set_ios = phytium_mci_ops_set_ios,
+	.get_cd = phytium_mci_get_cd,
+	.enable_sdio_irq = phytium_mci_enable_sdio_irq,
+	.ack_sdio_irq = phytium_mci_ack_sdio_irq,
+	.card_busy = phytium_mci_card_busy,
+	.start_signal_voltage_switch = phytium_mci_ops_switch_volt,
+	.hw_reset = phytium_mci_hw_reset,
+};
+
+int phytium_mci_common_probe(struct phytium_mci_host *host)
+{
+	struct mmc_host *mmc = host->mmc;
+	struct device *dev = host->dev;
+	int ret;
+
+	dma_set_mask(dev, DMA_BIT_MASK(64));
+	dma_set_coherent_mask(dev, DMA_BIT_MASK(64));
+
+	timer_setup(&host->hotplug_timer, hotplug_timer_func, 0);
+	timer_setup(&host->timeout_timer, phytium_mci_request_timeout, 0);
+
+	mmc->f_min = MCI_F_MIN;
+	if (!mmc->f_max)
+		mmc->f_max = MCI_F_MAX;
+
+	mmc->ops = &phytium_mci_ops;
+	mmc->ocr_avail_sdio = MMC_VDD_32_33 | MMC_VDD_33_34;
+	mmc->ocr_avail_sd = MMC_VDD_32_33 | MMC_VDD_33_34;
+	mmc->ocr_avail_mmc = MMC_VDD_165_195;
+	mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195;
+	mmc->caps |= host->caps;
+
+	if (mmc->caps & MMC_CAP_SDIO_IRQ) {
+		mmc->caps2 |= MMC_CAP2_SDIO_IRQ_NOTHREAD;
+		dev_dbg(host->dev, "%s %d: MMC_CAP_SDIO_IRQ\n", __func__, __LINE__);
+	}
+	mmc->caps2 |= host->caps2;
+	if (host->is_use_dma) {
+		/* MMC core transfer sizes tunable parameters */
+		mmc->max_segs = MAX_BD_NUM;
+		mmc->max_seg_size = 4 * 1024;
+		mmc->max_blk_size = 512;
+		mmc->max_req_size = 512 * 1024;
+		mmc->max_blk_count = mmc->max_req_size / 512;
+		host->dma.adma_table = dma_alloc_coherent(host->dev,
+							  MAX_BD_NUM *
+							  sizeof(struct phytium_adma2_64_desc),
+							  &host->dma.adma_addr, GFP_KERNEL);
+		if (!host->dma.adma_table)
+			return MCI_REALEASE_MEM;
+
+		host->dma.desc_sz = ADMA2_64_DESC_SZ;
+		phytium_mci_init_adma_table(host, &host->dma);
+	} else {
+		mmc->max_segs = MAX_BD_NUM;
+		mmc->max_seg_size = 4 * 1024;
+		mmc->max_blk_size = 512;
+		mmc->max_req_size = 4 * 512;
+		mmc->max_blk_count = mmc->max_req_size / 512;
+	}
+
+	spin_lock_init(&host->lock);
+
+	phytium_mci_init_hw(host);
+	ret = devm_request_irq(host->dev, host->irq, phytium_mci_irq,
+			       host->irq_flags, "phytium-mci", host);
+
+	if (ret)
+		return ret;
+
+	ret = mmc_add_host(mmc);
+
+	if (ret) {
+		dev_err(host->dev, "%s %d: mmc add host!\n", __func__, __LINE__);
+		return ret;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(phytium_mci_common_probe);
+
+MODULE_DESCRIPTION("Phytium Multimedia Card Interface driver");
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Cheng Quan <chengquan@phytium.com.cn>");
diff --git a/drivers/mmc/host/phytium-mci.h b/drivers/mmc/host/phytium-mci.h
new file mode 100644
index 000000000000..c35e6f3b3a85
--- /dev/null
+++ b/drivers/mmc/host/phytium-mci.h
@@ -0,0 +1,357 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Driver for Phytium Multimedia Card Interface
+ *
+ * Copyright (c) 2021-2024 Phytium Technology Co., Ltd.
+ */
+
+#ifndef __PHYTIUM_MCI_H
+#define __PHYTIUM_MCI_H
+
+#include <linux/scatterlist.h>
+#include <linux/compiler.h>
+#include <linux/types.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/interrupt.h>
+#include <linux/mmc/host.h>
+
+/*------------------------------------------------------*/
+/* Common Definition					*/
+/*------------------------------------------------------*/
+#define MAX_BD_NUM		128
+#define SD_BLOCK_SIZE		512
+
+#define MCI_BUS_1BITS          0x0
+#define MCI_BUS_4BITS          0x1
+#define MCI_BUS_8BITS          (0x1 << 16)
+
+#define MCI_SD_DRV_VALUE       0
+#define MCI_SD_SAMP_VALUE_MAX  0
+#define MCI_SD_SAMP_VALUE_MIN  0
+
+#define MCI_TIMEOUT_CMD_VALUE  0xFFFFFFFF
+#define MCI_POWER_ON           1
+#define MCI_POWER_OFF          0
+
+#define MCI_PREPARE_FLAG		(0x1 << 0)
+#define MCI_ASYNC_FLAG			(0x1 << 1)
+#define MCI_MMAP_FLAG			(0x1 << 2)
+
+#define MCI_CMD_TIMEOUT	(HZ/10 * 50)	/* 100ms x5 */
+#define MCI_DATA_TIMEOUT	(HZ    * 10)	/* 1000ms x5 */
+
+#define MCI_CMD_TYPE_ADTC      0x2
+
+#define MCI_F_MIN		400000
+#define MCI_F_MAX		50000000
+
+#define MCI_CLK		1200000000
+#define MCI_REALEASE_MEM	0x1
+#define MCI_MAX_FIFO_CNT	0x800
+
+/* FIFOTH register defines */
+#define MCI_SET_FIFOTH(m, r, t)	(((m) & 0x7) << 28 | \
+					 ((r) & 0xFFF) << 16 | ((t) & 0xFFF))
+/* Card read threshold */
+#define MCI_SET_THLD(v, x)		(((v) & 0xFFF) << 16 | (x))
+#define MCI_CARD_WR_THR_EN		BIT(2)
+#define MCI_CARD_RD_THR_EN		BIT(0)
+
+/*----------------------------------------------------------------------*/
+/* Register Offset							*/
+/*----------------------------------------------------------------------*/
+#define MCI_CNTRL		0x00 /* the controller config reg */
+#define MCI_PWREN		0x04 /* the power enable reg */
+#define MCI_CLKDIV		0x08 /* the clock divider reg */
+#define MCI_CLKENA		0x10 /* the clock enable reg */
+#define MCI_TMOUT		0x14 /* the timeout reg */
+#define MCI_CTYPE		0x18 /* the card type reg */
+#define MCI_BLKSIZ		0x1C /* the block size reg */
+#define MCI_BYTCNT		0x20 /* the byte count reg */
+#define MCI_INT_MASK		0x24 /* the interrupt mask reg */
+#define MCI_CMDARG		0x28 /* the command argument reg */
+#define MCI_CMD		0x2C /* the command reg */
+#define MCI_RESP0		0x30 /* the response reg0 */
+#define MCI_RESP1		0x34 /* the response reg1 */
+#define MCI_RESP2		0x38 /* the response reg2 */
+#define MCI_RESP3		0X3C /* the response reg3 */
+#define MCI_MASKED_INTS	0x40 /* the masked interrupt status reg */
+#define MCI_RAW_INTS		0x44 /* the raw interrupt status reg */
+#define MCI_STATUS		0x48 /* the status reg	*/
+#define MCI_FIFOTH		0x4C /* the FIFO threshold watermark reg */
+#define MCI_CARD_DETECT	0x50 /* the card detect reg */
+#define MCI_CARD_WRTPRT	0x54 /* the card write protect reg */
+#define MCI_CCLK_RDY		0x58 /* first div is ready? 1:ready,0:not ready*/
+#define MCI_TRAN_CARD_CNT	0x5C /* the transferred CIU card byte count reg */
+#define MCI_TRAN_FIFO_CNT	0x60 /* the transferred host to FIFO byte count reg  */
+#define MCI_DEBNCE		0x64 /* the debounce count reg */
+#define MCI_UID		0x68 /* the user ID reg */
+#define MCI_VID		0x6C /* the controller version ID reg */
+#define MCI_HWCONF		0x70 /* the hardware configuration reg */
+#define MCI_UHS_REG		0x74 /* the UHS-I reg */
+#define MCI_CARD_RESET		0x78 /* the card reset reg */
+#define MCI_BUS_MODE		0x80 /* the bus mode reg */
+#define MCI_DESC_LIST_ADDRL	0x88 /* the descriptor list low base address reg */
+#define MCI_DESC_LIST_ADDRH	0x8C /* the descriptor list high base address reg */
+#define MCI_DMAC_STATUS	0x90 /* the internal DMAC status reg */
+#define MCI_DMAC_INT_ENA	0x94 /* the internal DMAC interrupt enable reg */
+#define MCI_CUR_DESC_ADDRL	0x98 /* the current host descriptor low address reg */
+#define MCI_CUR_DESC_ADDRH	0x9C /* the current host descriptor high address reg */
+#define MCI_CUR_BUF_ADDRL	0xA0 /* the current buffer low address reg */
+#define MCI_CUR_BUF_ADDRH	0xA4 /* the current buffer high address reg */
+#define MCI_CARD_THRCTL	0x100 /* the card threshold control reg */
+#define MCI_UHS_REG_EXT	0x108 /* the UHS register extension */
+#define MCI_EMMC_DDR_REG	0x10C /* the EMMC DDR reg */
+#define MCI_ENABLE_SHIFT	0x110 /* the enable phase shift reg */
+#define MCI_DATA		0x200 /* the data FIFO access */
+
+/* Command register defines */
+#define MCI_CMD_START			BIT(31)
+#define MCI_CMD_USE_HOLD_REG		BIT(29)
+#define MCI_CMD_VOLT_SWITCH		BIT(28)
+#define MCI_CMD_CCS_EXP		BIT(23)
+#define MCI_CMD_CEATA_RD		BIT(22)
+#define MCI_CMD_UPD_CLK		BIT(21)
+#define MCI_CMD_INIT			BIT(15)
+#define MCI_CMD_STOP			BIT(14)
+#define MCI_CMD_PRV_DAT_WAIT		BIT(13)
+#define MCI_CMD_SEND_STOP		BIT(12)
+#define MCI_CMD_STRM_MODE		BIT(11)
+#define MCI_CMD_DAT_WR			BIT(10)
+#define MCI_CMD_DAT_EXP		BIT(9)
+#define MCI_CMD_RESP_CRC		BIT(8)
+#define MCI_CMD_RESP_LONG		BIT(7)
+#define MCI_CMD_RESP_EXP		BIT(6)
+#define MCI_CMD_INDX(n)		((n) & 0x1F)
+
+/*------------------------------------------------------*/
+/* Register Mask					*/
+/*------------------------------------------------------*/
+/* MCI_CNTRL mask */
+#define MCI_CNTRL_CONTROLLER_RESET	(0x1 << 0) /* RW */
+#define MCI_CNTRL_FIFO_RESET		(0x1 << 1) /* RW */
+#define MCI_CNTRL_DMA_RESET			(0x1 << 2) /* RW */
+#define MCI_CNTRL_RES				(0x1 << 3) /*  */
+#define MCI_CNTRL_INT_ENABLE		(0x1 << 4) /* RW */
+#define MCI_CNTRL_DMA_ENABLE		(0x1 << 5) /* RW */
+#define MCI_CNTRL_READ_WAIT			(0x1 << 6) /* RW */
+#define MCI_CNTRL_SEND_IRQ_RESPONSE	(0x1 << 7) /* RW */
+#define MCI_CNTRL_ABORT_READ_DATA	(0x1 << 8) /* RW */
+#define MCI_CNTRL_ENDIAN			(0x1 << 11) /* RW */
+//#define MCI_CNTRL_CARD_VOLTAGE_A	(0xF << 16) /* RW */
+//#define MCI_CNTRL_CARD_VOLTAGE_B	(0xF << 20) /* RW */
+#define MCI_CNTRL_ENABLE_OD_PULLUP	(0x1 << 24) /* RW */
+#define MCI_CNTRL_USE_INTERNAL_DMAC	(0x1 << 25) /* RW */
+
+/* MCI_PWREN mask */
+#define MCI_PWREN_ENABLE		(0x1 << 0)  /* RW */
+
+/* MCI_CLKENA mask */
+#define MCI_CLKENA_CCLK_ENABLE		(0x1 << 0) /* RW */
+#define MCI_CLKENA_CCLK_LOW_POWER	(0x1 << 16) /* RW */
+#define MCI_EXT_CLK_ENABLE		(0x1 << 1)
+
+/* MCI_INT_MASK mask */
+#define MCI_INT_MASK_CD		(0x1 << 0) /* RW */
+#define MCI_INT_MASK_RE		(0x1 << 1) /* RW */
+#define MCI_INT_MASK_CMD		(0x1 << 2) /* RW */
+#define MCI_INT_MASK_DTO		(0x1 << 3) /* RW */
+#define MCI_INT_MASK_TXDR		(0x1 << 4) /* RW */
+#define MCI_INT_MASK_RXDR		(0x1 << 5) /* RW */
+#define MCI_INT_MASK_RCRC		(0x1 << 6) /* RW */
+#define MCI_INT_MASK_DCRC		(0x1 << 7) /* RW */
+#define MCI_INT_MASK_RTO		(0x1 << 8) /* RW */
+#define MCI_INT_MASK_DRTO		(0x1 << 9) /* RW */
+#define MCI_INT_MASK_HTO		(0x1 << 10) /* RW */
+#define MCI_INT_MASK_FRUN		(0x1 << 11) /* RW */
+#define MCI_INT_MASK_HLE		(0x1 << 12) /* RW */
+#define MCI_INT_MASK_SBE_BCI		(0x1 << 13) /* RW */
+#define MCI_INT_MASK_ACD		(0x1 << 14) /* RW */
+#define MCI_INT_MASK_EBE		(0x1 << 15) /* RW */
+#define MCI_INT_MASK_SDIO		(0x1 << 16) /* RW */
+
+/* MCI_MASKED_INTS mask */
+#define MCI_MASKED_INTS_CD		(0x1 << 0) /* RO */
+#define MCI_MASKED_INTS_RE		(0x1 << 1) /* RO */
+#define MCI_MASKED_INTS_CMD		(0x1 << 2) /* RO */
+#define MCI_MASKED_INTS_DTO		(0x1 << 3) /* RO */
+#define MCI_MASKED_INTS_TXDR		(0x1 << 4) /* RO */
+#define MCI_MASKED_INTS_RXDR		(0x1 << 5) /* RO */
+#define MCI_MASKED_INTS_RCRC		(0x1 << 6) /* RO */
+#define MCI_MASKED_INTS_DCRC		(0x1 << 7) /* RO */
+#define MCI_MASKED_INTS_RTO		(0x1 << 8) /* RO */
+#define MCI_MASKED_INTS_DRTO		(0x1 << 9) /* RO */
+#define MCI_MASKED_INTS_HTO		(0x1 << 10) /* RO */
+#define MCI_MASKED_INTS_FRUN		(0x1 << 11) /* RO */
+#define MCI_MASKED_INTS_HLE		(0x1 << 12) /* RO */
+#define MCI_MASKED_INTS_SBE_BCI	(0x1 << 13) /* RO */
+#define MCI_MASKED_INTS_ACD		(0x1 << 14) /* RO */
+#define MCI_MASKED_INTS_EBE		(0x1 << 15) /* RO */
+#define MCI_MASKED_INTS_SDIO		(0x1 << 16) /* RO */
+
+/* MCI_RAW_INTS mask */
+#define MCI_RAW_INTS_CD		(0x1 << 0) /* W1C */
+#define MCI_RAW_INTS_RE		(0x1 << 1) /* W1C */
+#define MCI_RAW_INTS_CMD		(0x1 << 2) /* W1C */
+#define MCI_RAW_INTS_DTO		(0x1 << 3) /* W1C */
+#define MCI_RAW_INTS_TXDR		(0x1 << 4) /* W1C */
+#define MCI_RAW_INTS_RXDR		(0x1 << 5) /* W1C */
+#define MCI_RAW_INTS_RCRC		(0x1 << 6) /* W1C */
+#define MCI_RAW_INTS_DCRC		(0x1 << 7) /* W1C */
+#define MCI_RAW_INTS_RTO		(0x1 << 8) /* W1C */
+#define MCI_RAW_INTS_DRTO		(0x1 << 9) /* W1C */
+#define MCI_RAW_INTS_HTO		(0x1 << 10) /* W1C */
+#define MCI_RAW_INTS_FRUN		(0x1 << 11) /* W1C */
+#define MCI_RAW_INTS_HLE		(0x1 << 12) /* W1C */
+#define MCI_RAW_INTS_SBE_BCI		(0x1 << 13) /* W1C */
+#define MCI_RAW_INTS_ACD		(0x1 << 14) /* W1C */
+#define MCI_RAW_INTS_EBE		(0x1 << 15) /* W1C */
+#define MCI_RAW_INTS_SDIO		(0x1 << 16)  /* W1C */
+
+/* MCI_STATUS mask */
+#define MCI_STATUS_FIFO_RX		(0x1 << 0) /* RO */
+#define MCI_STATUS_FIFO_TX		(0x1 << 1) /* RO */
+#define MCI_STATUS_FIFO_EMPTY		(0x1 << 2) /* RO */
+#define MCI_STATUS_FIFO_FULL		(0x1 << 3) /* RO */
+#define MCI_STATUS_CARD_STATUS		(0x1 << 8) /* RO */
+#define MCI_STATUS_CARD_BUSY		(0x1 << 9) /* RO */
+#define MCI_STATUS_DATA_BUSY		(0x1 << 10) /* RO */
+#define MCI_STATUS_RESPOSE_INDEX_OFFSET		(11)
+#define MCI_STATUS_RESPOSE_INDEX_MASK		(0x3f << MCI_STATUS_RESPOSE_INDEX_OFFSET) /* RO */
+#define MCI_STATUS_RESPOSE_INDEX(reg)		(((reg) & MCI_STATUS_RESPOSE_INDEX_MASK) >> MCI_STATUS_RESPOSE_INDEX_OFFSET)
+#define MCI_STATUS_DMA_ACK		(0x1 << 31) /* RO */
+#define MCI_STATUS_DMA_REQ		(0x1 << 32) /* RO */
+
+/* MCI_UHS_REG mask */
+#define MCI_UHS_REG_VOLT		(0x1 << 0) /* RW */
+#define MCI_UHS_REG_DDR		(0x1 << 16) /* RW */
+
+/* MCI_CARD_RESET mask */
+#define MCI_CARD_RESET_ENABLE		(0x1 << 0) /* RW */
+
+/* MCI_BUS_MODE mask */
+#define MCI_BUS_MODE_SWR		(0x1 << 0) /* RW */
+#define MCI_BUS_MODE_FB		(0x1 << 1) /* RW */
+#define MCI_BUS_MODE_DE		(0x1 << 7) /* RW */
+
+/* MCI_DMAC_STATUS mask */
+#define MCI_DMAC_STATUS_TI		(0x1 << 0) /* RW */
+#define MCI_DMAC_STATUS_RI		(0x1 << 1) /* RW */
+#define MCI_DMAC_STATUS_FBE		(0x1 << 2) /* RW */
+#define MCI_DMAC_STATUS_DU		(0x1 << 4) /* RW */
+#define MCI_DMAC_STATUS_NIS		(0x1 << 8) /* RW */
+#define MCI_DMAC_STATUS_AIS		(0x1 << 9) /* RW */
+
+/* MCI_DMAC_INT_ENA mask */
+#define MCI_DMAC_INT_ENA_TI		(0x1 << 0) /* RW */
+#define MCI_DMAC_INT_ENA_RI		(0x1 << 1) /* RW */
+#define MCI_DMAC_INT_ENA_FBE		(0x1 << 2) /* RW */
+#define MCI_DMAC_INT_ENA_DU		(0x1 << 4) /* RW */
+#define MCI_DMAC_INT_ENA_CES		(0x1 << 5) /* RW */
+#define MCI_DMAC_INT_ENA_NIS		(0x1 << 8) /* RW */
+#define MCI_DMAC_INT_ENA_AIS		(0x1 << 9) /* RW */
+
+/* MCI_CARD_THRCTL mask */
+#define MCI_CARD_THRCTL_CARDRD		(0x1 << 0) /* RW */
+#define MCI_CARD_THRCTL_BUSY_CLR	(0x1 << 1) /* RW */
+#define MCI_CARD_THRCTL_CARDWR		(0x1 << 2) /* RW */
+
+/* MCI_UHS_REG_EXT mask */
+#define MCI_UHS_REG_EXT_MMC_VOLT	(0x1 << 0) /* RW */
+#define MCI_UHS_REG_EXT_CLK_ENA	(0x1 << 1) /* RW */
+
+/* MCI_EMMC_DDR_REG mask */
+#define MCI_EMMC_DDR_CYCLE		(0x1 << 0) /* RW */
+
+/*--------------------------------------*/
+/*		Structure Type		*/
+/*--------------------------------------*/
+/* Maximum segments assuming a 512KiB maximum requisition */
+/* size and a minimum4KiB page size. */
+#define MCI_MAX_SEGS		128
+/* ADMA2 64-bit DMA descriptor size */
+#define ADMA2_64_DESC_SZ	32
+
+/* mmc request timeout 5000ms */
+#define MMC_REQ_TIMEOUT_MS 5000
+
+/* Each descriptor can transfer up to 4KB of data in chained mode */
+/*ADMA2 64-bit descriptor.*/
+struct phytium_adma2_64_desc {
+	u32 attribute;
+#define IDMAC_DES0_DIC	BIT(1)
+#define IDMAC_DES0_LD	BIT(2)
+#define IDMAC_DES0_FD	BIT(3)
+#define IDMAC_DES0_CH	BIT(4)
+#define IDMAC_DES0_ER	BIT(5)
+#define IDMAC_DES0_CES	BIT(30)
+#define IDMAC_DES0_OWN	BIT(31)
+	u32	NON1;
+	u32	len;
+	u32	NON2;
+	u32	addr_lo; /* Lower 32-bits of Buffer Address Pointer 1*/
+	u32	addr_hi; /* Upper 32-bits of Buffer Address Pointer 1*/
+	u32	desc_lo; /* Lower 32-bits of Next Descriptor Address */
+	u32	desc_hi; /* Upper 32-bits of Next Descriptor Address */
+} __packed __aligned(4);
+
+struct phytium_mci_dma {
+	struct scatterlist *sg;	/* I/O scatter list */
+	/* ADMA descriptor table, pointer to adma_table array */
+	struct phytium_adma2_64_desc *adma_table;
+	/* Mapped ADMA descr. table, the physical address of adma_table array */
+	dma_addr_t adma_addr;
+	unsigned int desc_sz;	/* ADMA descriptor size */
+};
+
+enum adtc_t {
+	COMMOM_ADTC	= 0,
+	BLOCK_RW_ADTC	= 1
+};
+
+struct phytium_mci_host {
+	struct device *dev;
+	struct mmc_host *mmc;
+	u32 caps;
+	u32 caps2;
+	spinlock_t lock;
+	struct mmc_request *mrq;
+	struct mmc_command *cmd;
+	struct mmc_data *data;
+	int error;
+	void __iomem *base;		    /* host base address */
+	void *adma_table1;
+	dma_addr_t adma_addr1;
+	struct phytium_mci_dma dma_rx;	/* dma channel */
+	struct phytium_mci_dma dma_tx;	/* dma channel */
+	struct phytium_mci_dma dma;	/* dma channel */
+	u64 dma_mask;
+	bool vqmmc_enabled;
+	u32 *sg_virt_addr;
+	enum adtc_t adtc_type;      /* 0:common adtc cmd; 1:block r/w adtc cmd;*/
+	struct timer_list hotplug_timer;
+	struct timer_list timeout_timer;
+	struct delayed_work req_timeout;
+	int irq;		    /* host interrupt */
+	u32 current_rca;    /*the current rca value*/
+	u32 current_ios_clk;
+	u32 is_use_dma;
+	u32 is_device_x100;
+	struct clk *src_clk;	    /* phytium_mci source clock */
+	unsigned long clk_rate;
+	unsigned long clk_div;
+	unsigned long irq_flags;
+	unsigned long flags;
+#define MCI_CARD_NEED_INIT	1
+
+};
+
+int phytium_mci_common_probe(struct phytium_mci_host *host);
+void phytium_mci_deinit_hw(struct phytium_mci_host *host);
+int phytium_mci_runtime_suspend(struct device *dev);
+int phytium_mci_runtime_resume(struct device *dev);
+int phytium_mci_resume(struct device *dev);
+int phytium_mci_suspend(struct device *dev);
+
+#endif /* __PHYTIUM_MCI_HW_H */
diff --git a/drivers/mmc/host/phytium-sdci.c b/drivers/mmc/host/phytium-sdci.c
new file mode 100755
index 000000000000..b4ca402c1da5
--- /dev/null
+++ b/drivers/mmc/host/phytium-sdci.c
@@ -0,0 +1,1433 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Phytium SD Card Interface dirver
+ *
+ * Copyright (c) 2019-2024 Phytium Technology Co., Ltd.
+ */
+
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/ioport.h>
+#include <linux/irq.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_gpio.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/acpi.h>
+#include <linux/timer.h>
+
+#include <linux/mmc/card.h>
+#include <linux/mmc/core.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/sd.h>
+#include <linux/mmc/sdio.h>
+
+#include "phytium-sdci.h"
+
+static const u32 cmd_ints_mask = SDCI_SDCI_NORMAL_ISER_ECC_EN | SDCI_SDCI_NORMAL_ISER_EEI_EN;
+static const u32 data_ints_mask = SDCI_BD_ISER_ETRS_EN;
+static const u32 err_ints_mask = SDCI_ERROR_ISER_ECTE_EN | SDCI_ERROR_ISR_CCRCE_EN |
+				  SDCI_ERROR_ISR_CIR_EN | SDCI_ERROR_ISR_CNR_EN;
+
+static void hotplug_timer_func(struct timer_list *t);
+static bool phytium_sdci_private_send_cmd(struct phytium_sdci_host *host,
+					  u32 cmd, u32 resp_type, u32 arg);
+static bool phytium_sdci_cmd_done(struct phytium_sdci_host *host, int events,
+				  struct mmc_request *mrq,
+				  struct mmc_command *cmd);
+static bool phytium_sdci_data_xfer_done(struct phytium_sdci_host *host,
+					u32 events, struct mmc_request *mrq,
+					struct mmc_data *data);
+static void phytium_sdci_cmd_next(struct phytium_sdci_host *host,
+				  struct mmc_request *mrq,
+				  struct mmc_command *cmd);
+
+static int phytium_sdci_cmd13_process(struct phytium_sdci_host *host,
+				       struct mmc_request *mrq,
+				       struct mmc_data *data,
+				       u32 wait_timeout_ms,
+				       u32 send_once_time_ms);
+
+static int phytium_sd_error(struct phytium_sdci_host *host)
+{
+	int temp;
+
+	temp = readl(host->base + SDCI_NORMAL_ISR);
+	dev_err(host->dev, "[%s %d]SDCI_NORMAL_ISR:%x\n", __func__, __LINE__, temp);
+	temp = readl(host->base + SDCI_BD_ISR);
+	temp = readl(host->base + SDCI_ERROR_ISR);
+	dev_err(host->dev, "[%s %d]SDCI_ERROR_ISR:%x\n", __func__, __LINE__, temp);
+	temp = readl(host->base + SDCI_BD_ISR);
+	dev_err(host->dev, "[%s %d]SDCI_BD_ISR:%x\n", __func__, __LINE__, temp);
+	temp = readl(host->base + SDCI_RESP0);
+	dev_err(host->dev, "[%s %d]SDCI_RESP0:%x\n", __func__, __LINE__, temp);
+
+	return 0;
+}
+
+static void sdr_set_bits(void __iomem *reg, u32 bs)
+{
+	u32 val;
+
+	val = readl(reg);
+	val |= bs;
+
+	writel(val, reg);
+}
+
+static void sdr_clr_bits(void __iomem *reg, u32 bs)
+{
+	u32 val;
+
+	val = readl(reg);
+	val &= ~bs;
+
+	writel(val, reg);
+}
+
+static void phytium_sdci_reset_hw(struct phytium_sdci_host *host)
+{
+	sdr_set_bits(host->base + SDCI_SOFTWARE,
+		     SDCI_SOFTWARE_SRST);
+	sdr_clr_bits(host->base + SDCI_SOFTWARE,
+		     SDCI_SOFTWARE_SRST);
+	while (!(readl(host->base + SDCI_STATUS) & SDCI_STATUS_IDIE))
+		cpu_relax();
+}
+
+static void phytium_sdci_prepare_data(struct phytium_sdci_host *host,
+				      struct mmc_request *mrq)
+{
+	struct mmc_data *data = mrq->data;
+	bool read;
+
+	read = (data->flags & MMC_DATA_READ) != 0;
+	data->sg_count = dma_map_sg(host->dev, data->sg, data->sg_len,
+				    read ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
+}
+
+static void phytium_sdci_unprepare_data(struct phytium_sdci_host *host,
+					struct mmc_request *mrq)
+{
+	bool read;
+	struct mmc_data *data = mrq->data;
+
+	read = (data->flags & MMC_DATA_READ) != 0;
+	dma_unmap_sg(host->dev, data->sg, data->sg_len,
+		     read ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
+}
+
+static void phytium_sdci_set_clk(struct phytium_sdci_host *host,
+				 struct mmc_ios *ios)
+{
+	unsigned long clk_rate;
+	u32 div = 0xffffffff, div_reg;
+
+	if (ios->clock) {
+		clk_rate = host->clk_rate;
+		div = ((clk_rate / (2 * ios->clock)) - 1);
+		div_reg = readl(host->base + SDCI_CLOCK_D);
+		if (div_reg == div)
+			return;
+		writel(div, host->base + SDCI_CLOCK_D);
+		writel(0, host->base + SDCI_SD_DRV);
+		writel(5, host->base + SDCI_SD_SAMP);
+
+		sdr_set_bits(host->base + SDCI_SOFTWARE, SDCI_SOFTWARE_SRST);
+		sdr_clr_bits(host->base + SDCI_SOFTWARE, SDCI_SOFTWARE_SRST);
+		while (!(readl(host->base + SDCI_STATUS) & SDCI_STATUS_IDIE))
+			cpu_relax();
+		dev_dbg(host->dev, "host->clk_rate: %ld, ios->clock: %d\n",
+			host->clk_rate, ios->clock);
+	}
+}
+
+
+static inline u32 phytium_sdci_cmd_find_resp(struct phytium_sdci_host *host,
+					     struct mmc_request *mrq,
+					     struct mmc_command *cmd)
+{
+	u32 resp;
+
+	switch (mmc_resp_type(cmd)) {
+	case MMC_RSP_R1:
+		resp = 0x2;
+		break;
+	case MMC_RSP_R1B:
+		resp = 0x2;
+		break;
+	case MMC_RSP_R2:
+		resp = 0x1;
+		break;
+	case MMC_RSP_R3:
+		resp = 0x3;
+		break;
+	case MMC_RSP_NONE:
+	default:
+		resp = 0x0;
+		break;
+	}
+
+	return resp;
+}
+
+static inline u32 phytium_sdci_cmd_prepare_raw_cmd(struct phytium_sdci_host *host,
+		struct mmc_request *mrq, struct mmc_command *cmd)
+{
+	/*
+	 * rawcmd :
+	 *   trty << 14 | opcode << 8 | cmdw << 6 | cice << 4 | crce << 3 | resp
+	 */
+	u32 resp, rawcmd;
+	u32 opcode = cmd->opcode;
+
+	resp = phytium_sdci_cmd_find_resp(host, mrq, cmd);
+	rawcmd = ((opcode << 8) | resp);
+
+	if ((cmd->flags & MMC_CMD_MASK) == MMC_CMD_ADTC)
+		rawcmd = (rawcmd | (SDCI_CMD_TYPE_ADTC << 14));
+
+	return rawcmd;
+}
+
+static void
+phytium_sdci_unexpected_error_handler(struct phytium_sdci_host *host,
+				       struct mmc_request *mrq,
+				       struct mmc_data *data,
+				       int err_type)
+{
+	unsigned long flags;
+	int error;
+
+	spin_lock_irqsave(&host->lock, flags);
+	host->mrq = NULL;
+	host->cmd = NULL;
+	host->data = NULL;
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	if (err_type & ERR_CARD_ABSENT) {
+		host->mmc->detect_change = 1;
+		dev_dbg(host->dev, "SD is absent when send cmd:%d\n", mrq->cmd->opcode);
+	}
+
+	switch (err_type) {
+	case ERR_CARD_ABSENT:
+		error = -ENOMEDIUM;
+		break;
+	case ERR_TIMEOUT:
+		error = -ETIMEDOUT;
+		break;
+	case ERR_CMD_RESPONED:
+		error = -EIO;
+		break;
+	default:
+		error = -ETIMEDOUT;
+		break;
+	}
+
+	if (data) {
+		data->error = error;
+		phytium_sdci_unprepare_data(host, mrq);
+
+		if ((data->flags & MMC_DATA_READ) == MMC_DATA_READ ||
+		    (data->flags & MMC_DATA_WRITE) == MMC_DATA_WRITE)
+			phytium_sdci_data_xfer_done(host, SDCI_BD_ISR_TRS_R, mrq, data);
+	} else {
+		mrq->cmd->error = error;
+	}
+
+	mmc_request_done(host->mmc, mrq);
+}
+
+static bool phytium_sdci_start_data(struct phytium_sdci_host *host, struct mmc_request *mrq,
+			    struct mmc_command *cmd, struct mmc_data *data)
+{
+	bool read, res;
+	u32 sg_dma_addrh, sg_dma_addrl;
+	u32 sd_block_addrh, sd_block_addrl;
+	u32 temp, timeout, sd_status;
+	u32 block_cnt = 0;
+	u32 sd_block_addr = cmd->arg;
+	u32 private_cmd, resp_type, arg;
+	u32 j, dma_len;
+	unsigned long deadline_time;
+	dma_addr_t dma_address;
+	struct scatterlist *sg;
+	int ret;
+
+	WARN_ON(host->cmd);
+	host->cmd = cmd;
+
+	WARN_ON(host->data);
+	host->data = data;
+	read = data->flags & MMC_DATA_READ;
+
+	for_each_sg(data->sg, sg, data->sg_count, j) {
+		writel(0, host->base + SDCI_COMMAND);
+
+		dma_address = sg_dma_address(sg);
+		sg_dma_addrh = (u32) (dma_address >> 32);
+		sg_dma_addrl = (u32) dma_address;
+
+		dma_len = sg_dma_len(sg);
+		block_cnt = (dma_len / SD_BLOCK_SIZE);
+
+		sd_block_addrh = 0;
+		sd_block_addrl = sd_block_addr;
+
+		sdr_set_bits(host->base + SDCI_SOFTWARE, SDCI_SOFTWARE_BDRST);
+		sdr_clr_bits(host->base + SDCI_SOFTWARE, SDCI_SOFTWARE_BDRST);
+		writel(block_cnt, host->base + SDCI_BLK_CNT);
+
+		if ((mrq->data->flags & MMC_DATA_READ) == MMC_DATA_READ) {
+			writel(sg_dma_addrl, host->base + SDCI_BD_RX);
+			writel(sg_dma_addrh, host->base + SDCI_BD_RX);
+			writel(sd_block_addrl, host->base + SDCI_BD_RX);
+			writel(sd_block_addrh, host->base + SDCI_BD_RX);
+			timeout = 100 * block_cnt;
+		} else {
+			timeout = 250 * block_cnt;
+			ret = phytium_sdci_cmd13_process(host, mrq, data, timeout, 1);
+			if (ret != SDCI_CMD13_OK)
+				return false;
+
+			writel(sg_dma_addrl, host->base + SDCI_BD_TX);
+			writel(sg_dma_addrh, host->base + SDCI_BD_TX);
+			writel(sd_block_addrl, host->base + SDCI_BD_TX);
+			writel(sd_block_addrh, host->base + SDCI_BD_TX);
+		}
+
+		deadline_time = jiffies + msecs_to_jiffies(timeout);
+
+		temp = readl(host->base + SDCI_BD_ISR);
+		if ((mrq->data->flags & MMC_DATA_READ) == MMC_DATA_READ) {
+			while ((temp & SDCI_BD_ISR_TRS_R) != SDCI_BD_ISR_TRS_R) {
+				sd_status = readl(host->base + SDCI_STATUS);
+				if (sd_status & SDCI_STATUS_CDSL) {
+					phytium_sdci_unexpected_error_handler(host, mrq, data,
+									      ERR_CARD_ABSENT);
+					if (temp & SDCI_BD_ISR_DAIS)
+						writel(1, host->base + SDCI_BD_ISR);
+					return false;
+				}
+
+				temp = readl(host->base + SDCI_BD_ISR);
+				if (time_after(jiffies, deadline_time)) {
+					phytium_sdci_unexpected_error_handler(host, mrq, data,
+									      ERR_TIMEOUT);
+					dev_err(host->dev,
+						"Read Data timeout:jiffies:0x%lx,dt_jiffies: 0x%lx, BD_isr_reg:0x%x,cmd:%d, REG_D0:0x%x\n",
+						jiffies, jiffies - deadline_time, temp,
+						cmd->opcode, readl(host->base + SDCI_STATUS));
+
+					return false;
+				}
+			}
+		} else {
+			while ((temp & SDCI_BD_ISR_TRS_W) != SDCI_BD_ISR_TRS_W) {
+				sd_status = readl(host->base + SDCI_STATUS);
+				if (sd_status & SDCI_STATUS_CDSL) {
+					phytium_sdci_unexpected_error_handler(host, mrq, data,
+									      ERR_CARD_ABSENT);
+					dev_err(host->dev, "[%s][%d]: Card absent ! cmd(%d)\n",
+						__func__, __LINE__, mrq->cmd->opcode);
+					return false;
+				}
+
+				temp = readl(host->base + SDCI_BD_ISR);
+				if (time_after(jiffies, deadline_time)) {
+					phytium_sdci_unexpected_error_handler(host, mrq, data,
+									      ERR_TIMEOUT);
+					dev_err(host->dev,
+						"Write Date timeout: jiffies:0x%lx,dt_jiffies: 0x%lx,BD_isr_reg:0x%x\n",
+						jiffies, jiffies - deadline_time, temp);
+					return false;
+				}
+			}
+		}
+		writel(1, host->base + SDCI_BD_ISR);
+		writel(1, host->base + SDCI_NORMAL_ISR);
+		sd_block_addr = sd_block_addr + block_cnt;
+
+		if (j < (data->sg_count - 1) && 1 < block_cnt) {
+			private_cmd = MMC_STOP_TRANSMISSION;
+			resp_type = 0x2;
+			arg = 0;
+			res = phytium_sdci_private_send_cmd(host, private_cmd,
+							    resp_type, arg);
+			if (!res) {
+				sd_status = readl(host->base + SDCI_STATUS);
+				if (sd_status & SDCI_STATUS_CDSL) {
+					phytium_sdci_unexpected_error_handler(host, mrq, data,
+									      ERR_CARD_ABSENT);
+					writel(1, host->base + SDCI_BD_ISR);
+					dev_err(host->dev,
+						"[%s][%d]:Card absent ! private_cmd(%d)\n",
+						__func__, __LINE__, private_cmd);
+				} else {
+					phytium_sdci_unexpected_error_handler(host, mrq, data,
+									      ERR_CMD_RESPONED);
+					dev_err(host->dev,
+						"[%s][%d] cmd(%d) response errored\n",
+						__func__, __LINE__, mrq->cmd->opcode);
+					phytium_sd_error(host);
+				}
+				writel(1, host->base + SDCI_NORMAL_ISR);
+				return false;
+			}
+			writel(1, host->base + SDCI_NORMAL_ISR);
+		}
+	}
+
+	host->is_multi_rw_only_one_blkcnt = false;
+
+	if ((cmd->opcode == MMC_READ_MULTIPLE_BLOCK && block_cnt == 1) ||
+	    (cmd->opcode == MMC_WRITE_MULTIPLE_BLOCK && block_cnt == 1))
+		host->is_multi_rw_only_one_blkcnt = true;
+
+	phytium_sdci_cmd_done(host, SDCI_NORMAL_ISR_CC, mrq, cmd);
+	if ((mrq->data->flags & MMC_DATA_READ) == MMC_DATA_READ)
+		phytium_sdci_data_xfer_done(host, SDCI_BD_ISR_TRS_R,
+					    mrq, data);
+	else
+		phytium_sdci_data_xfer_done(host, SDCI_BD_ISR_TRS_W,
+					    mrq, data);
+
+	return true;
+}
+
+static int phytium_sdci_auto_cmd_done(struct phytium_sdci_host *host,
+				      int events, struct mmc_command *cmd)
+{
+	u32 *rsp = cmd->resp;
+
+	rsp[0] = readl(host->base + SDCI_RESP0);
+
+	if (events & SDCI_NORMAL_ISR_CC)
+		cmd->error = 0;
+	else {
+		phytium_sdci_reset_hw(host);
+		dev_err(host->dev,
+			"%s: AUTO_CMD%d arg=%08X; rsp %08X; cmd_error=%d\n",
+			__func__, cmd->opcode, cmd->arg, rsp[0], cmd->error);
+	}
+
+	return cmd->error;
+}
+
+static void phytium_sdci_track_cmd_data(struct phytium_sdci_host *host,
+					struct mmc_command *cmd,
+					struct mmc_data *data)
+{
+	if (host->error)
+		dev_dbg(host->dev, "%s: cmd=%d arg=%08X; host->error=0x%08X\n",
+			__func__, cmd->opcode, cmd->arg, host->error);
+}
+
+static void phytium_sdci_request_done(struct phytium_sdci_host *host,
+				      struct mmc_request *mrq)
+{
+	unsigned long flags;
+
+	dev_dbg(host->dev,
+		"%s_%d:mrq->cmd->opcode:%d, mrq->cmd->arg:0x%x resp 0x%x 0x%x 0x%x 0x%x\n",
+		__func__, __LINE__, mrq->cmd->opcode, mrq->cmd->arg,
+		mrq->cmd->resp[0], mrq->cmd->resp[1], mrq->cmd->resp[2],
+		mrq->cmd->resp[3]);
+
+	spin_lock_irqsave(&host->lock, flags);
+	host->mrq = NULL;
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	phytium_sdci_track_cmd_data(host, mrq->cmd, mrq->data);
+	if (mrq->data)
+		phytium_sdci_unprepare_data(host, mrq);
+	mmc_request_done(host->mmc, mrq);
+}
+
+static bool
+phytium_sdci_auto_command_done(struct phytium_sdci_host *host, int events,
+			       struct mmc_request *mrq, struct mmc_command *cmd)
+{
+	u32 *rsp = cmd->resp;
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+	host->cmd = NULL;
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	sdr_clr_bits(host->base + SDCI_NORMAL_ISER, cmd_ints_mask);
+
+	rsp[0] = 0x900;
+	phytium_sdci_request_done(host, mrq);
+	return true;
+}
+
+/* returns true if command is fully handled; returns false otherwise */
+static bool phytium_sdci_cmd_done(struct phytium_sdci_host *host, int events,
+				  struct mmc_request *mrq,
+				  struct mmc_command *cmd)
+{
+	bool done = false;
+	bool sbc_error;
+	unsigned long flags;
+	u32 *rsp = cmd->resp;
+
+	if (mrq->sbc && cmd == mrq->cmd &&
+	    (events & SDCI_NORMAL_ISR_CC))
+		phytium_sdci_auto_cmd_done(host, events, mrq->sbc);
+
+	sbc_error = mrq->sbc && mrq->sbc->error;
+
+	if (!sbc_error && !(events & (SDCI_NORMAL_ISR_CC |
+				      SDCI_NORMAL_ISR_CR |
+				      SDCI_NORMAL_ISR_TIMEOUT)))
+		return done;
+
+	spin_lock_irqsave(&host->lock, flags);
+	done = !host->cmd;
+	host->cmd = NULL;
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	if (done)
+		return true;
+
+	sdr_clr_bits(host->base + SDCI_NORMAL_ISER, cmd_ints_mask);
+
+	if (cmd->flags & MMC_RSP_PRESENT) {
+		if (cmd->flags & MMC_RSP_136) {
+			rsp[0] = readl(host->base + SDCI_RESP0);
+			rsp[1] = readl(host->base + SDCI_RESP1);
+			rsp[2] = readl(host->base + SDCI_RESP2);
+			rsp[3] = readl(host->base + SDCI_RESP3);
+		} else
+			rsp[0] = readl(host->base + SDCI_RESP0);
+
+		if (cmd->opcode == SD_SEND_RELATIVE_ADDR)
+			host->current_rca = rsp[0] & 0xFFFF0000;
+	}
+
+	if (!sbc_error &&
+	    !(events & SDCI_NORMAL_ISR_CC) &&
+	    (events & SDCI_NORMAL_ISR_TIMEOUT))
+		cmd->error = -ETIMEDOUT;
+
+	if (cmd->error)
+		dev_dbg(host->dev,
+			"%s: cmd=%d arg=%08X; rsp %08X; cmd_error=%d\n",
+			__func__, cmd->opcode, cmd->arg, rsp[0],
+			cmd->error);
+
+	phytium_sdci_cmd_next(host, mrq, cmd);
+
+	return true;
+}
+
+static bool set_databus_width(struct phytium_sdci_host *host)
+{
+	bool res;
+	u32 cmd, resp_type, arg;
+
+	cmd = SD_APP_SET_BUS_WIDTH;
+	resp_type = 0x2;
+	arg = 0x2;
+	res = phytium_sdci_private_send_cmd(host, cmd, resp_type, arg);
+	if (!res)
+		return false;
+
+	cmd = MMC_APP_CMD;
+	resp_type = 0x2;
+	arg = host->current_rca;
+	res = phytium_sdci_private_send_cmd(host, cmd, resp_type, arg);
+	if (!res)
+		return false;
+
+	return true;
+}
+
+
+static void phytium_sdci_start_command(struct phytium_sdci_host *host,
+				       struct mmc_request *mrq,
+				       struct mmc_command *cmd)
+{
+	u32 rawcmd;
+	struct mmc_data *data = mrq->data;
+	dma_addr_t dma_adtc_buf;
+	u32 dma_bufh, dma_bufl, block_cnt = 0;
+
+	WARN_ON(host->cmd);
+	host->cmd = cmd;
+
+	cmd->error = 0;
+	rawcmd = phytium_sdci_cmd_prepare_raw_cmd(host, mrq, cmd);
+	if (cmd->opcode == MMC_STOP_TRANSMISSION ||
+	    cmd->opcode == MMC_SEND_STATUS)
+		writel(1, host->base + SDCI_ERROR_ISR);
+	sdr_set_bits(host->base + SDCI_NORMAL_ISER, cmd_ints_mask);
+	writel(rawcmd, host->base + SDCI_COMMAND);
+
+	if ((cmd->flags & MMC_CMD_MASK) == MMC_CMD_ADTC) {
+		WARN_ON(host->data);
+		host->data = data;
+
+		dma_adtc_buf = host->dma_rx.bd_addr;
+		dma_bufh = (u32) (dma_adtc_buf >> 32);
+		dma_bufl = (u32) dma_adtc_buf;
+		block_cnt = mrq->data->blocks;
+		sdr_set_bits(host->base + SDCI_BD_ISER, data_ints_mask);
+		writel(block_cnt, host->base + SDCI_BLK_CNT);
+
+		if ((mrq->data->flags & MMC_DATA_READ) == MMC_DATA_READ) {
+			writel(dma_bufl, host->base + SDCI_BD_RX);
+			writel(dma_bufh, host->base + SDCI_BD_RX);
+			writel(cmd->arg, host->base + SDCI_BD_RX);
+			writel(0, host->base + SDCI_BD_RX);
+		} else {
+			writel(dma_bufl, host->base + SDCI_BD_TX);
+			writel(dma_bufh, host->base + SDCI_BD_TX);
+			writel(cmd->arg, host->base + SDCI_BD_TX);
+			writel(0, host->base + SDCI_BD_TX);
+		}
+	} else {
+		writel(cmd->arg, host->base + SDCI_ARGUMENT);
+	}
+}
+
+static void phytium_sdci_cmd_next(struct phytium_sdci_host *host,
+				  struct mmc_request *mrq,
+				  struct mmc_command *cmd)
+{
+	if (cmd->error || (mrq->sbc && mrq->sbc->error))
+		phytium_sdci_request_done(host, mrq);
+	else if (cmd == mrq->sbc)
+		phytium_sdci_start_command(host, mrq, mrq->cmd);
+	else if (!cmd->data)
+		phytium_sdci_request_done(host, mrq);
+}
+
+static int phytium_sdci_cmd13_process(struct phytium_sdci_host *host,
+				       struct mmc_request *mrq,
+				       struct mmc_data *data,
+				       u32 wait_timeout_ms,
+				       u32 send_once_time_ms)
+{
+	u32 private_cmd, resp_type, arg, temp, sd_status;
+	unsigned long deadline_time;
+	bool res;
+
+	deadline_time = jiffies + msecs_to_jiffies(wait_timeout_ms);
+
+	do {
+		private_cmd = MMC_SEND_STATUS;
+		resp_type = 0x2;
+		arg = host->current_rca;
+
+		res = phytium_sdci_private_send_cmd(host, private_cmd, resp_type, arg);
+		if (!res) {
+			sd_status = readl(host->base + SDCI_STATUS);
+			if (sd_status & SDCI_STATUS_CDSL) {
+				phytium_sdci_unexpected_error_handler(host, mrq, data,
+								      ERR_CARD_ABSENT);
+				dev_err(host->dev,
+					"[%s][%d] Card absent! private_cmd(%d)\n",
+					__func__, __LINE__, private_cmd);
+			} else {
+				phytium_sdci_unexpected_error_handler(host, mrq, data,
+								      ERR_CMD_RESPONED);
+
+				dev_err(host->dev,
+					"[%s][%d] private_cmd(%d) response errored\n",
+					__func__, __LINE__, private_cmd);
+				phytium_sd_error(host);
+			}
+			writel(1, host->base + SDCI_BD_ISR);
+			return SDCI_CMD13_FAILED;
+		}
+
+		temp = readl(host->base + SDCI_RESP0);
+
+		if (time_after(jiffies, deadline_time)) {
+
+			if (mrq->cmd->opcode == MMC_SEND_STATUS)
+				return SDCI_CMD13_OK;
+
+			dev_err(host->dev,
+				"SD card is not in transfer mode,timeout:%d,rsp[0]:%x\n",
+				wait_timeout_ms, temp);
+
+			phytium_sdci_unexpected_error_handler(host, mrq, data,
+							      ERR_TIMEOUT);
+			phytium_sd_error(host);
+			return SDCI_CMD13_FAILED;
+		}
+
+		writel(1, host->base + SDCI_NORMAL_ISR);
+
+		if (CARD_TRAN_STATE != (temp & CARD_CURRENT_STATE) && send_once_time_ms)
+			mdelay(send_once_time_ms);
+
+	} while (CARD_TRAN_STATE != (temp & CARD_CURRENT_STATE));
+
+	return SDCI_CMD13_OK;
+}
+
+static void phytium_sdci_ops_request(struct mmc_host *mmc,
+				     struct mmc_request *mrq)
+{
+	struct phytium_sdci_host *host = mmc_priv(mmc);
+	unsigned long flags;
+	bool res;
+	u32 status_sd;
+	int res_cmd13;
+
+	host->error = 0;
+	WARN_ON(host->mrq);
+	host->mrq = mrq;
+
+	dev_dbg(host->dev, "%s: mrq->cmd->opcode: %d, mrq->cmd->arg: 0x%x\n",
+		__func__, mrq->cmd->opcode, mrq->cmd->arg);
+
+	if (mrq->cmd->opcode == MMC_SEND_STATUS &&
+	    (mrq->cmd->flags & MMC_CMD_MASK) != MMC_CMD_ADTC) {
+		u32 status = readl(host->base + SDCI_STATUS);
+
+		if (status & SDCI_STATUS_CDSL) {
+			phytium_sdci_unexpected_error_handler(host, mrq, NULL,
+							      ERR_CARD_ABSENT);
+			return;
+		}
+
+		res_cmd13 = phytium_sdci_cmd13_process(host, mrq, NULL, 400, 5);
+		if (res_cmd13 == SDCI_CMD13_FAILED)
+			return;
+	} else if (mrq->cmd->opcode == MMC_STOP_TRANSMISSION) {
+		status_sd = readl(host->base + SDCI_STATUS);
+		if (status_sd & SDCI_STATUS_CDSL) {
+			phytium_sdci_unexpected_error_handler(host, mrq, NULL,
+							      ERR_CARD_ABSENT);
+			return;
+		}
+	}
+
+	if (mrq->data) {
+		phytium_sdci_prepare_data(host, mrq);
+		if (mrq->cmd->opcode == MMC_READ_MULTIPLE_BLOCK ||
+		    mrq->cmd->opcode == MMC_READ_SINGLE_BLOCK ||
+		    mrq->cmd->opcode == MMC_WRITE_MULTIPLE_BLOCK ||
+		    mrq->cmd->opcode == MMC_WRITE_BLOCK) {
+			host->adtc_type = BLOCK_RW_ADTC;
+			phytium_sdci_start_data(host, mrq,
+						mrq->cmd, mrq->data);
+			return;
+		}
+		host->adtc_type = COMMOM_ADTC;
+	}
+
+	if (mrq->cmd->opcode == SD_IO_RW_DIRECT ||
+	    mrq->cmd->opcode == SD_IO_SEND_OP_COND) {
+		spin_lock_irqsave(&host->lock, flags);
+		host->mrq = NULL;
+		host->cmd = NULL;
+		spin_unlock_irqrestore(&host->lock, flags);
+		mrq->cmd->error = -EINVAL;
+		mmc_request_done(host->mmc, mrq);
+
+		return;
+	}
+
+	if (mrq->cmd->opcode == SD_APP_SEND_SCR) {
+		res = set_databus_width(host);
+		if (!res) {
+			phytium_sdci_unexpected_error_handler(host, mrq, NULL, ERR_CMD_RESPONED);
+			return;
+		}
+	}
+
+	/* if SBC is required, we have HW option and SW option.
+	 * if HW option is enabled, and SBC does not have "special" flags,
+	 * use HW option,  otherwise use SW option
+	 */
+	if (mrq->sbc &&
+	    (!mmc_card_mmc(mmc->card) || (mrq->sbc->arg & 0xFFFF0000)))
+		phytium_sdci_start_command(host, mrq, mrq->sbc);
+	else
+		phytium_sdci_start_command(host, mrq, mrq->cmd);
+}
+
+static void phytium_sdci_data_xfer_next(struct phytium_sdci_host *host,
+					struct mmc_request *mrq,
+					struct mmc_data *data)
+{
+	if (mmc_op_multi(mrq->cmd->opcode) &&
+	    mrq->stop && !mrq->stop->error &&
+	    !mrq->sbc && host->is_multi_rw_only_one_blkcnt) {
+		host->is_multi_rw_only_one_blkcnt = false;
+		phytium_sdci_auto_command_done(host, SDCI_NORMAL_ISR_CC, mrq, mrq->stop);
+	} else if (mmc_op_multi(mrq->cmd->opcode) &&
+		   mrq->stop && !mrq->stop->error &&
+		   !mrq->sbc)
+		phytium_sdci_start_command(host, mrq, mrq->stop);
+	else
+		phytium_sdci_request_done(host, mrq);
+}
+
+static inline void get_data_buffer(struct mmc_data *data,
+				   u32 *bytes, u32 **pointer)
+{
+	struct scatterlist *sg;
+
+	sg = &data->sg[0];
+	*bytes = sg->length;
+	*pointer = sg_virt(sg);
+}
+
+static bool phytium_sdci_data_xfer_done(struct phytium_sdci_host *host,
+					u32 events, struct mmc_request *mrq,
+					struct mmc_data *data)
+{
+	struct mmc_command *stop = data->stop;
+	unsigned long flags;
+	bool done;
+	unsigned int check_data;
+	u32 sg_length, i;
+	u32 *sg_virt_addr;
+
+	check_data = events & (SDCI_BD_ISR_TRS_R | SDCI_BD_ISR_TRS_W | SDCI_BD_ISR_EDTE);
+
+	spin_lock_irqsave(&host->lock, flags);
+	done = !host->data;
+	if (check_data)
+		host->data = NULL;
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	if (done)
+		return true;
+
+	if (check_data || (stop && stop->error)) {
+		sdr_clr_bits(host->base + SDCI_BD_ISER, data_ints_mask);
+		dev_dbg(host->dev, "DMA stop\n");
+
+		if (((events & SDCI_BD_ISR_TRS_R) ||
+		     (events & SDCI_BD_ISR_TRS_W)) &&
+		     (!stop || !stop->error)) {
+			if ((mrq->cmd->flags & MMC_CMD_MASK) == MMC_CMD_ADTC &&
+			    (host->adtc_type == COMMOM_ADTC)) {
+				get_data_buffer(data, &sg_length,
+						&host->sg_virt_addr);
+				sg_virt_addr = host->sg_virt_addr;
+
+				for (i = 0; i < (sg_length/4); i++) {
+					*sg_virt_addr = host->dma_rx.buf[i];
+					sg_virt_addr++;
+				}
+			}
+			data->bytes_xfered = data->blocks * data->blksz;
+		} else {
+			dev_dbg(host->dev, "interrupt events: %x\n", events);
+			phytium_sdci_reset_hw(host);
+			data->bytes_xfered = 0;
+			dev_dbg(host->dev, "%s: cmd=%d; blocks=%d",
+				__func__, mrq->cmd->opcode, data->blocks);
+			dev_dbg(host->dev, "data_error=%d xfer_size=%d\n",
+				(int)data->error, data->bytes_xfered);
+		}
+
+		phytium_sdci_data_xfer_next(host, mrq, data);
+		done = true;
+	}
+
+	return done;
+}
+
+
+static int phytium_sdci_card_busy(struct mmc_host *mmc)
+{
+	struct phytium_sdci_host *host = mmc_priv(mmc);
+	u32 status;
+
+	/* check if any pin between dat[0:3] is low */
+	status = readl(host->base + SDCI_STATUS);
+	if (((status >> 20) & 0xf) != 0xf)
+		return 1;
+
+	return 0;
+}
+
+static void phytium_sdci_request_timeout(struct work_struct *work)
+{
+	struct phytium_sdci_host *host;
+
+	host = container_of(work, struct phytium_sdci_host, req_timeout.work);
+	dev_err(host->dev, "%s: aborting cmd/data/mrq\n", __func__);
+	if (host->mrq) {
+		dev_err(host->dev, "%s: aborting mrq=%p cmd=%d\n", __func__,
+			host->mrq, host->mrq->cmd->opcode);
+		if (host->cmd) {
+			dev_err(host->dev, "%s: aborting cmd=%d\n",
+				__func__, host->cmd->opcode);
+			phytium_sdci_cmd_done(host, SDCI_NORMAL_ISR_TIMEOUT,
+					      host->mrq, host->cmd);
+		} else if (host->data) {
+			dev_err(host->dev, "%s: abort data: cmd%d; %d blocks\n",
+				__func__, host->mrq->cmd->opcode,
+				host->data->blocks);
+			phytium_sdci_data_xfer_done(host, SDCI_BD_ISR_EDTE,
+						    host->mrq, host->data);
+		}
+	}
+}
+
+static void hotplug_timer_func(struct timer_list *t)
+{
+	struct phytium_sdci_host *host;
+	u32 status;
+
+	host = from_timer(host, t, hotplug_timer);
+	if (!host)
+		dev_err(host->dev, "%s: Not find host!\n", __func__);
+	status = readl(host->base + SDCI_STATUS);
+
+	if (status & SDCI_STATUS_CDSL) { /* card absent */
+		if (host->mmc->card) {
+			cancel_delayed_work(&host->mmc->detect);
+			mmc_detect_change(host->mmc,
+					msecs_to_jiffies(100));
+		}
+	} else { /* card insert */
+		cancel_delayed_work(&host->mmc->detect);
+		mmc_detect_change(host->mmc, msecs_to_jiffies(200));
+	}
+}
+
+static irqreturn_t phytium_sdci_irq(int irq, void *dev_id)
+{
+	struct phytium_sdci_host *host = (struct phytium_sdci_host *) dev_id;
+	unsigned long flags;
+	struct mmc_request *mrq;
+	struct mmc_command *cmd;
+	u32 events;
+
+	if (!host)
+		return IRQ_NONE;
+
+	spin_lock_irqsave(&host->lock, flags);
+	events = readl(host->base + SDCI_NORMAL_ISR);
+	/* clear interrupts */
+	writel(1, host->base + SDCI_NORMAL_ISR);
+
+	mrq = host->mrq;
+	cmd = host->cmd;
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	if (events & (SDCI_NORMAL_ISR_CR | SDCI_NORMAL_ISR_CI)) {
+		mod_timer(&host->hotplug_timer,
+			  jiffies + usecs_to_jiffies(30000));
+		goto irq_out;
+	}
+
+	if (!(events & cmd_ints_mask))
+		goto irq_out;
+
+	if (!mrq) {
+		dev_err(host->dev, "%s: MRQ=NULL; events=%08X\n",
+			__func__, events);
+		WARN_ON(1);
+		goto irq_out;
+	}
+
+	dev_dbg(host->dev, "%s: events=%08X\n", __func__, events);
+
+	if (cmd)
+		phytium_sdci_cmd_done(host, events, mrq, cmd);
+
+irq_out:
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t phytium_sdci_dma_irq(int irq, void *dev_id)
+{
+	struct phytium_sdci_host *host = (struct phytium_sdci_host *) dev_id;
+	unsigned long flags;
+	struct mmc_request *mrq;
+	struct mmc_command *cmd;
+	struct mmc_data *data;
+	u32 events;
+
+	spin_lock_irqsave(&host->lock, flags);
+	events = readl(host->base + SDCI_BD_ISR);
+	writel(1, host->base + SDCI_BD_ISR);
+
+	mrq = host->mrq;
+	cmd = host->cmd;
+	data = host->data;
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	if (!(events & data_ints_mask))
+		goto dma_irq_out;
+
+	if (!mrq) {
+		dev_err(host->dev,
+			"%s: MRQ=NULL; events=%08X\n",
+			__func__, events);
+		goto dma_irq_out;
+	}
+
+	dev_dbg(host->dev, "%s: events=%08X\n", __func__, events);
+
+	if (data)
+		phytium_sdci_data_xfer_done(host, events, mrq, data);
+
+dma_irq_out:
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t phytium_sdci_err_irq(int irq, void *dev_id)
+{
+	struct phytium_sdci_host *host = (struct phytium_sdci_host *) dev_id;
+	unsigned long flags;
+	struct mmc_request *mrq;
+	struct mmc_command *cmd;
+	struct mmc_data *data;
+	u32 events;
+
+	if (!host)
+		return IRQ_NONE;
+
+	spin_lock_irqsave(&host->lock, flags);
+	events = readl(host->base + SDCI_ERROR_ISR);
+	mrq = host->mrq;
+	cmd = host->cmd;
+	data = host->data;
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	if (!(events&err_ints_mask))
+		goto err_irq_out;
+
+	if (!mrq) {
+		sdr_clr_bits(host->base + SDCI_NORMAL_ISER, SDCI_NORMAL_ISR_EI);
+		writel(1, host->base + SDCI_ERROR_ISR);
+		dev_err(host->dev, "%s: MRQ=NULL; events=%08X\n", __func__, events);
+		goto err_irq_out;
+	}
+	sdr_clr_bits(host->base + SDCI_NORMAL_ISER, SDCI_NORMAL_ISR_EI);
+	if (data) {
+		dev_err(host->dev,
+			"[%s][%d]:  cmd(%d); %d read blocks, status:%x,flag:%x\n",
+			__func__, __LINE__, mrq->cmd->opcode, data->blocks, events, data->flags);
+		data->error = -ETIMEDOUT;
+		if ((data->flags & MMC_DATA_READ) == MMC_DATA_READ ||
+		    (data->flags & MMC_DATA_WRITE) == MMC_DATA_WRITE)
+			phytium_sdci_data_xfer_done(host, SDCI_BD_ISR_EDTE | SDCI_BD_ISR_TRS_R,
+						    mrq, data);
+		mrq->cmd->error = -ETIMEDOUT;
+		mmc_request_done(host->mmc, mrq);
+	} else if (cmd) {
+		phytium_sdci_cmd_done(host, SDCI_NORMAL_ISR_TIMEOUT, mrq, cmd);
+	}
+
+	writel(1, host->base + SDCI_NORMAL_ISR);
+	writel(1, host->base + SDCI_ERROR_ISR);
+err_irq_out:
+	return IRQ_HANDLED;
+}
+
+static void phytium_sdci_init_hw(struct phytium_sdci_host *host)
+{
+	u32 val;
+
+	/* Reset */
+	phytium_sdci_reset_hw(host);
+
+	val = SDCI_SEN_CREFR_VAL | SDCI_SEN_DEBNCE_VAL;
+	writel(val, host->base + SDCI_SD_SEN);
+
+	/* Disable and clear all interrupts */
+	writel(0, host->base + SDCI_NORMAL_ISER);
+	writel(0, host->base + SDCI_ERROR_ISER);
+	writel(0, host->base + SDCI_BD_ISER);
+
+	writel(1, host->base + SDCI_NORMAL_ISR);
+	writel(1, host->base + SDCI_ERROR_ISR);
+	writel(1, host->base + SDCI_BD_ISR);
+
+	sdr_set_bits(host->base + SDCI_NORMAL_ISER,
+		     SDCI_SDCI_NORMAL_ISER_ECI|SDCI_SDCI_NORMAL_ISER_ECR);
+	/* Configure default cmd timeout to 0.1(s)s = val/25M */
+	val = SDCI_F_MAX / 10;
+	writel(val, host->base + SDCI_TIMEOUT_CMD);
+	writel(SDCI_TIMEOUT_DATA_VALUE, host->base + SDCI_TIMEOUT_DATA);
+
+	val = 0x0F00;
+	writel(val, host->base + SDCI_CONTROLLER);
+
+	dev_dbg(host->dev, "init hardware done!");
+}
+
+static void phytium_sdci_deinit_hw(struct phytium_sdci_host *host)
+{
+	/* Disable and clear all interrupts */
+	writel(0, host->base + SDCI_NORMAL_ISER);
+	writel(0, host->base + SDCI_ERROR_ISER);
+	writel(0, host->base + SDCI_BD_ISER);
+
+	writel(0, host->base + SDCI_NORMAL_ISR);
+	writel(0, host->base + SDCI_ERROR_ISR);
+	writel(0, host->base + SDCI_BD_ISR);
+}
+
+static void phytium_sdci_ops_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct phytium_sdci_host *host = mmc_priv(mmc);
+
+	if (ios->bus_width == MMC_BUS_WIDTH_4)
+		mmc->caps = mmc->caps & (~MMC_CAP_4_BIT_DATA);
+
+	/* Suspend/Resume will do power off/on */
+	switch (ios->power_mode) {
+	case MMC_POWER_UP:
+		writel(SDCI_POWER_ON, host->base + SDCI_POWER);
+		break;
+	case MMC_POWER_ON:
+		phytium_sdci_set_clk(host, ios);
+		break;
+	case MMC_POWER_OFF:
+		writel(SDCI_POWER_OFF, host->base + SDCI_POWER);
+		break;
+	default:
+		break;
+	}
+}
+
+static int phytium_sdci_get_cd(struct mmc_host *mmc)
+{
+	struct phytium_sdci_host *host = mmc_priv(mmc);
+	u32 status = readl(host->base + SDCI_STATUS);
+
+	if (((status >> 19) & 0x1) == 0x1)
+		return 0;
+
+	return 1;
+}
+
+static void phytium_sdci_hw_reset(struct mmc_host *mmc)
+{
+	struct phytium_sdci_host *host = mmc_priv(mmc);
+
+	sdr_set_bits(host->base + SDCI_SOFTWARE, SDCI_SOFTWARE_SRST);
+	sdr_clr_bits(host->base + SDCI_SOFTWARE, SDCI_SOFTWARE_SRST);
+	while (!(readl(host->base + SDCI_STATUS) & SDCI_STATUS_IDIE))
+		cpu_relax();
+}
+
+static struct mmc_host_ops phytium_sdci_ops = {
+	.request = phytium_sdci_ops_request,
+	.set_ios = phytium_sdci_ops_set_ios,
+	.get_cd = phytium_sdci_get_cd,
+	.card_busy = phytium_sdci_card_busy,
+	.hw_reset = phytium_sdci_hw_reset,
+};
+
+static bool phytium_sdci_private_send_cmd(struct phytium_sdci_host *host,
+					  u32 cmd, u32 resp_type, u32 arg)
+{
+	u32 temp, sd_cmd, sd_arg, sd_status;
+	unsigned long deadline_time;
+
+	writel(1, host->base + SDCI_NORMAL_ISR);
+	writel(1, host->base + SDCI_ERROR_ISR);
+
+	sd_cmd = (cmd << 8) | resp_type;
+	sd_arg = arg;
+	writel(sd_cmd, host->base + SDCI_COMMAND);
+	writel(sd_arg, host->base + SDCI_ARGUMENT);
+
+	if (cmd == MMC_STOP_TRANSMISSION)
+		deadline_time = jiffies + msecs_to_jiffies(1000);
+	else
+		deadline_time = jiffies + msecs_to_jiffies(100);
+
+	temp = readl(host->base + SDCI_NORMAL_ISR);
+	while ((temp & SDCI_NORMAL_ISR_CC) != SDCI_NORMAL_ISR_CC) {
+		sd_status = readl(host->base + SDCI_STATUS);
+		if (sd_status & SDCI_STATUS_CDSL)
+			return false;
+
+		temp = readl(host->base + SDCI_NORMAL_ISR);
+		if (time_after(jiffies, deadline_time))
+			return false;
+
+		if (cmd == MMC_STOP_TRANSMISSION)
+			mdelay(1);
+	}
+
+	return true;
+}
+
+static int phytium_sdci_probe(struct platform_device *pdev)
+{
+	struct mmc_host *mmc;
+	struct phytium_sdci_host *host;
+	struct resource *res;
+	int ret;
+	const struct acpi_device_id *match;
+	struct device *dev = &pdev->dev;
+
+	/* Allocate MMC host for this device */
+	mmc = mmc_alloc_host(sizeof(struct phytium_sdci_host), &pdev->dev);
+	if (!mmc)
+		return -ENOMEM;
+
+	host = mmc_priv(mmc);
+	ret = mmc_of_parse(mmc);
+	if (ret)
+		goto host_free;
+
+	if (dev->of_node) {
+		host->src_clk = devm_clk_get(&pdev->dev, "phytium_sdc_clk");
+		if (IS_ERR(host->src_clk)) {
+			ret = PTR_ERR(host->src_clk);
+			goto host_free;
+		}
+
+		host->clk_rate = clk_get_rate(host->src_clk);
+		if (device_property_read_bool(dev, "no-dma-coherent"))
+			dev->dma_coherent = false;
+	} else if (has_acpi_companion(dev)) {
+		match = acpi_match_device(dev->driver->acpi_match_table, dev);
+		if (!match) {
+			dev_err(dev, "Error ACPI match data is missing\n");
+			return -ENODEV;
+		}
+
+		acpi_dma_configure(dev, DEV_DMA_NOT_SUPPORTED);
+
+		host->clk_rate = 600000000;
+	} else {
+		dev_err(&pdev->dev, "No DT found\n");
+		return -EINVAL;
+	}
+
+	dma_set_mask(dev, DMA_BIT_MASK(40));
+	dma_set_coherent_mask(dev, DMA_BIT_MASK(40));
+
+	timer_setup(&host->hotplug_timer, hotplug_timer_func, 0);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	host->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(host->base)) {
+		ret = PTR_ERR(host->base);
+		goto host_free;
+	}
+
+	host->irq = platform_get_irq(pdev, 1);
+	if (host->irq < 0) {
+		ret = -EINVAL;
+		goto host_free;
+	}
+
+	host->irq_err = platform_get_irq(pdev, 2);
+	if (host->irq_err < 0) {
+		ret = -EINVAL;
+		goto host_free;
+	}
+
+	host->irq_bd = platform_get_irq(pdev, 0);
+	if (host->irq_bd < 0) {
+		ret = -EINVAL;
+		goto host_free;
+	}
+
+	host->dev = &pdev->dev;
+	host->mmc = mmc;
+
+	if ((4 * SDCI_F_MAX) > host->clk_rate)
+		host->clk_div	= 1;
+	else
+		host->clk_div	= ((host->clk_rate / (2 * SDCI_F_MAX)) - 1);
+
+	/* Set host parameters to mmc */
+	mmc->f_min = SDCI_F_MIN;
+	mmc->f_max = (host->clk_rate / ((host->clk_div + 1) * 2));
+	mmc->ops = &phytium_sdci_ops;
+	mmc->ocr_avail	= MMC_VDD_32_33 | MMC_VDD_33_34;
+
+	mmc->caps |= host->caps;
+	/* MMC core transfer sizes tunable parameters */
+	mmc->max_segs = MAX_BD_NUM;
+	mmc->max_seg_size = 512 * 1024;
+	mmc->max_blk_size = 512;
+	mmc->max_req_size = 512 * 1024;
+	mmc->max_blk_count = mmc->max_req_size / 512;
+
+	host->dma_rx.buf = dma_alloc_coherent(&pdev->dev,
+					       MAX_BD_NUM,
+					       &host->dma_rx.bd_addr,
+					       GFP_KERNEL);
+	if (!host->dma_rx.buf) {
+		ret = -ENOMEM;
+		goto release_mem;
+	}
+
+	host->cmd_timeout = msecs_to_jiffies(100);
+	host->data_timeout = msecs_to_jiffies(250);
+
+	INIT_DELAYED_WORK(&host->req_timeout, phytium_sdci_request_timeout);
+	spin_lock_init(&host->lock);
+
+	platform_set_drvdata(pdev, mmc);
+	phytium_sdci_init_hw(host);
+
+	ret = devm_request_irq(&pdev->dev, host->irq, phytium_sdci_irq,
+			       IRQF_SHARED, pdev->name, host);
+	if (ret)
+		goto release;
+
+	ret = devm_request_irq(&pdev->dev, host->irq_err, phytium_sdci_err_irq,
+			       IRQF_SHARED, pdev->name, host);
+	if (ret)
+		goto release;
+
+	ret = devm_request_irq(&pdev->dev, host->irq_bd, phytium_sdci_dma_irq,
+			       IRQF_SHARED, pdev->name, host);
+	if (ret)
+		goto release;
+
+	ret = mmc_add_host(mmc);
+	if (ret)
+		goto release;
+
+	return 0;
+
+release:
+	platform_set_drvdata(pdev, NULL);
+	phytium_sdci_deinit_hw(host);
+release_mem:
+	if (host->dma_rx.buf)
+		dma_free_coherent(&pdev->dev, MAX_BD_NUM,
+				  host->dma_rx.buf,
+				  host->dma_rx.bd_addr);
+host_free:
+	mmc_free_host(mmc);
+
+	return ret;
+}
+
+static int phytium_sdci_remove(struct platform_device *pdev)
+{
+	struct mmc_host *mmc;
+	struct phytium_sdci_host *host;
+
+	mmc = platform_get_drvdata(pdev);
+	host = mmc_priv(mmc);
+
+	cancel_delayed_work_sync(&host->req_timeout);
+	platform_set_drvdata(pdev, NULL);
+	mmc_remove_host(host->mmc);
+	phytium_sdci_deinit_hw(host);
+
+	if (host->dma_rx.buf)
+		dma_free_coherent(&pdev->dev, MAX_BD_NUM,
+				  host->dma_rx.buf, host->dma_rx.bd_addr);
+
+	mmc_free_host(host->mmc);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int phytium_sdci_suspend(struct device *dev)
+{
+	struct mmc_host *mmc = dev_get_drvdata(dev);
+	struct phytium_sdci_host *host = mmc_priv(mmc);
+
+	phytium_sdci_deinit_hw(host);
+	return 0;
+}
+
+static int phytium_sdci_resume(struct device *dev)
+{
+	struct mmc_host *mmc = dev_get_drvdata(dev);
+	struct phytium_sdci_host *host = mmc_priv(mmc);
+
+	phytium_sdci_init_hw(host);
+	mmc->caps = mmc->caps | MMC_CAP_4_BIT_DATA;
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PM
+static int phytium_sdci_runtime_suspend(struct device *dev)
+{
+	struct mmc_host *mmc = dev_get_drvdata(dev);
+	struct phytium_sdci_host *host = mmc_priv(mmc);
+
+	phytium_sdci_deinit_hw(host);
+
+	return 0;
+}
+
+static int phytium_sdci_runtime_resume(struct device *dev)
+{
+	struct mmc_host *mmc = dev_get_drvdata(dev);
+	struct phytium_sdci_host *host = mmc_priv(mmc);
+
+	phytium_sdci_init_hw(host);
+
+	return 0;
+}
+
+static const struct dev_pm_ops phytium_sdci_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(phytium_sdci_suspend,
+				phytium_sdci_resume)
+	SET_RUNTIME_PM_OPS(phytium_sdci_runtime_suspend,
+			   phytium_sdci_runtime_resume, NULL)
+};
+#else
+#define phytium_sdci_dev_pm_ops NULL
+#endif
+
+static const struct of_device_id phytium_sdci_of_ids[] = {
+	{ .compatible = "phytium,sdci", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, phytium_sdci_of_ids);
+
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id phytium_sdci_acpi_ids[] = {
+	{ .id = "PHYT0005" },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(acpi, phytium_sdci_acpi_ids);
+#else
+#define phytium_sdci_acpi_ids NULL
+#endif
+
+static struct platform_driver phytium_sdci_driver = {
+	.probe = phytium_sdci_probe,
+	.remove = phytium_sdci_remove,
+	.driver = {
+		.name = "sdci-phytium",
+		.of_match_table = phytium_sdci_of_ids,
+		.acpi_match_table = phytium_sdci_acpi_ids,
+		.pm = &phytium_sdci_dev_pm_ops,
+	},
+};
+
+module_platform_driver(phytium_sdci_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Cheng Quan <chengquan@phytium.com.cn>");
+MODULE_AUTHOR("Chen Baozi <chenbaozi@phytium.com.cn>");
+MODULE_DESCRIPTION("Phytium SD Card Interface driver");
diff --git a/drivers/mmc/host/phytium-sdci.h b/drivers/mmc/host/phytium-sdci.h
new file mode 100755
index 000000000000..d53f8b5e0edb
--- /dev/null
+++ b/drivers/mmc/host/phytium-sdci.h
@@ -0,0 +1,200 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Phytium SD Card Interface driver
+ *
+ * Copyright (c) 2019-2024 Phytium Technology Co., Ltd.
+ */
+
+/*---------------------------------------------------------------------------*/
+/* Common Definition                                                         */
+/*---------------------------------------------------------------------------*/
+#define MAX_BD_NUM           0x1000
+#define SD_BLOCK_SIZE        512
+
+/*---------------------------------------------------------------------------*/
+/* Register Offset                                                           */
+/*---------------------------------------------------------------------------*/
+#define SDCI_CONTROLLER      0x00  /* controller config reg                  */
+#define SDCI_ARGUMENT        0x04  /* argument reg                           */
+#define SDCI_COMMAND         0x08  /* command reg                            */
+#define SDCI_CLOCK_D         0x0C  /* clock divide reg                       */
+#define SDCI_SOFTWARE        0x10  /* controller reset reg                   */
+#define SDCI_POWER           0X14  /* POWRE CONTROL REG                      */
+#define SDCI_TIMEOUT_CMD     0x18  /* cmd timeout config reg                 */
+#define SDCI_TIMEOUT_DATA    0x1C  /* data timeout reg                       */
+#define SDCI_NORMAL_ISER     0x20  /* normal ISR config reg                  */
+#define SDCI_ERROR_ISER      0x24  /* erroe ISR config reg                   */
+#define SDCI_BD_ISER         0x28  /* BD ISR config reg                      */
+#define SDCI_CAPA            0x2C  /* BD ISR config reg                      */
+#define SDCI_SD_DRV          0x30  /* SD card driving phase position reg     */
+#define SDCI_SD_SAMP         0x34  /* SD card sampling phase position reg    */
+#define SDCI_SD_SEN          0x38  /* SD card detection reg                  */
+#define SDCI_HDS_AXI         0x3C  /* AXI boundary config reg                */
+#define SDCI_BD_RX           0x40  /* BD rx addr reg                         */
+#define SDCI_BD_TX           0x60  /* BD tx addr reg                         */
+#define SDCI_BLK_CNT         0x80  /* r/w block num reg                      */
+#define SDCI_NORMAL_ISR      0xC0  /* normal ISR status reg                  */
+#define SDCI_ERROR_ISR       0xC4  /* error ISR status reg                   */
+#define SDCI_BD_ISR          0xC8  /* BD ISR status reg                      */
+#define SDCI_BD_STATUS       0xCC  /* BD descriptor status reg               */
+#define SDCI_STATUS          0xD0  /* status reg                             */
+#define SDCI_BLOCK           0xD4  /* block len reg                          */
+#define SDCI_RESP0           0xE0  /* response reg0                          */
+#define SDCI_RESP1           0xE4  /* response reg1                          */
+#define SDCI_RESP2           0xE8  /* response reg2                          */
+#define SDCI_RESP3           0XEC  /* response reg3                          */
+
+/*---------------------------------------------------------------------------*/
+/* Register Mask                                                             */
+/*---------------------------------------------------------------------------*/
+/* SDCI_CONTROLLER mask */
+#define SDCI_CONTROLLER_ECRCWR		(0x1 << 0)	/* RW */
+#define SDCI_CONTROLLER_ECRCRD		(0x1 << 1)	/* RW */
+#define SDCI_CONTROLLER_RESEDE		(0x1 << 2)	/* RW */
+#define SDCI_CONTROLLER_PERMDR		(0x3 << 8)	/* RW */
+#define SDCI_CONTROLLER_PERMDX		(0x3 << 10)	/* RW */
+
+/* SDCI_SOFTWARE mask */
+#define SDCI_SOFTWARE_SRST		(0x1 << 0)	/* RW */
+#define SDCI_SOFTWARE_SCRST		(0x1 << 1)	/* RW */
+#define SDCI_SOFTWARE_BDRST		(0x1 << 2)	/* RW */
+#define SDCI_SOFTWARE_CFCLF		(0x1 << 3)	/* RW */
+#define SDCI_SOFTWARE_SDRST		(0x1 << 4)	/* RW */
+
+/* SDCI_NORMAL_ISER mask */
+#define SDCI_SDCI_NORMAL_ISER_ECC_EN	(0x1 << 0)	/* RW */
+#define SDCI_SDCI_NORMAL_ISER_ECR	(0x1 << 1)	/* RW */
+#define SDCI_SDCI_NORMAL_ISER_ECI	(0x1 << 2)	/* RW */
+#define SDCI_SDCI_NORMAL_ISER_EEI_EN	(0x1 << 15)	/* RW */
+
+/* SDCI_NORMAL_ISR mask */
+#define SDCI_NORMAL_ISR_CC		(0x1 << 0)	/* R  */
+#define SDCI_NORMAL_ISR_CR		(0x1 << 1)	/* R  */
+#define SDCI_NORMAL_ISR_CI		(0x1 << 2)	/* R  */
+#define SDCI_NORMAL_ISR_TIMEOUT		(0x1 << 3)	/* R  */
+#define SDCI_NORMAL_ISR_EI		(0x1 << 15)	/* R  */
+
+/* SDCI_ERROR_ISER mask */
+#define SDCI_ERROR_ISER_ECTE_EN		(0x1 << 0)	/* RW */
+#define SDCI_ERROR_ISR_CCRCE_EN		(0x1 << 1)	/* RW */
+#define SDCI_ERROR_ISR_CIR_EN		(0x1 << 3)	/* RW */
+#define SDCI_ERROR_ISR_CNR_EN		(0x1 << 4)	/* RW */
+/* SDCI_ERROR_ISR mask */
+#define SDCI_ERROR_ISR_CTE		(0x1 << 0)	/* R  */
+#define SDCI_ERROR_ISR_CCRCE		(0x1 << 1)	/* R  */
+#define SDCI_ERROR_ISR_CIR		(0x1 << 3)	/* R  */
+#define SDCI_ERROR_ISR_CNR		(0x1 << 4)	/* R  */
+
+/* SDCI_BD_ISER mask */
+#define SDCI_BD_ISER_ETRS_EN		(0x1 << 8)	/* RW */
+#define SDCI_BD_ISER_DATFRAX_EN		(0x1 << 7)	/* RW */
+
+/* SDCI_BD_ISR mask */
+#define SDCI_BD_ISR_TRS_W		(0x1 << 0)	/* R  */
+#define SDCI_BD_ISR_TRS_R		(0x1 << 8)	/* R  */
+#define SDCI_BD_ISR_EDTE		(0x1 << 3)	/* R  */
+#define SDCI_BD_ISR_DAIS		(0x1 << 15)	/* R  */
+#define SDCI_BD_ISR_DATFRAX		(0x1 << 7)	/* R  */
+
+/* SDCI_HDS_AXI mask */
+#define SDCI_HDS_AXI_AWDOMAIN		(0x1 << 0)	/* RW */
+#define SDCI_HDS_AXI_ARDOMAIN		(0x1 << 12)	/* RW */
+#define SDCI_HDS_AXI_AWCACHE		(0x6 << 24)	/* RW */
+#define SDCI_HDS_AXI_ARCACHE		(0xB << 28)	/* RW */
+
+/* SDCI_STATUS mask */
+#define SDCI_STATUS_CMD_BUSY		(0x0 << 0)	/* R  */
+#define SDCI_STATUS_CMD_READY		(0x1 << 0)	/* R  */
+#define SDCI_STATUS_IDIE		(0x1 << 12)	/* R  */
+#define SDCI_CARD_BUSY_IN_PRG		(0x1 << 20)	/* R D0 BUSY:0,IDLE:1 */
+
+/* SDCI_STATUS */
+#define SDCI_STATUS_CDSL		(0x1 << 19)	/* R  */
+
+/*---------------------------------------------------------------------------*/
+/* Register Value                                                            */
+/*---------------------------------------------------------------------------*/
+#define SDCI_SD_DRV_VALUE		0
+#define SDCI_SD_SAMP_VALUE_MAX		50
+#define SDCI_SD_SAMP_VALUE_MIN		0
+
+#define SDCI_TIMEOUT_CMD_VALUE		0xFFFFFFFF
+#define SDCI_TIMEOUT_DATA_VALUE		0xFFFFFFFF
+#define SDCI_POWER_ON			1
+#define SDCI_POWER_OFF			0
+
+#define SDCI_CMD_TIMEOUT		10
+#define SDCI_DAT_TIMEOUT		5000
+
+#define SDCI_CMD_TYPE_ADTC		0x2
+
+#define SDCI_F_MIN			400000
+#define SDCI_F_MAX			25000000
+
+#define SDCI_SEN_CREFR_VAL		(0x1 << 1)
+#define SDCI_SEN_DEBNCE_VAL		(0xB << 8)
+
+#define CARD_CURRENT_STATE		(0xF << 9)
+#define CARD_PRG_STATE			(0x7 << 9)
+#define CARD_TRAN_STATE		(0x4 << 9)
+
+#define SDCI_CMD13_OK			1
+#define SDCI_CMD13_FAILED		0
+
+#define ERR_TIMEOUT			(0x1 << 0)
+#define ERR_CARD_ABSENT		(0x1 << 1)
+#define ERR_CMD_RESPONED		(0x1 << 2)
+
+/*---------------------------------------------------------------------------*/
+/*  Structure Type                                                           */
+/*---------------------------------------------------------------------------*/
+struct phytium_sdci_dma {
+	struct scatterlist *sg;
+	u32 *buf;
+	dma_addr_t bd_addr;
+	size_t bytes;
+};
+
+enum adtc_type {
+	COMMOM_ADTC = 0,
+	BLOCK_RW_ADTC,
+};
+
+struct phytium_sdci_host {
+	struct device *dev;
+	struct mmc_host *mmc;
+	u32 caps;
+	spinlock_t lock;
+
+	struct mmc_request *mrq;
+	struct mmc_command *cmd;
+	struct mmc_data *data;
+	int error;
+
+	void __iomem *base;
+
+	struct phytium_sdci_dma dma_rx;
+	struct phytium_sdci_dma dma_tx;
+
+	u32 *sg_virt_addr;
+	enum adtc_type adtc_type;
+
+	struct timer_list hotplug_timer;
+
+	struct delayed_work req_timeout;
+	u32 cmd_timeout;
+	u32 data_timeout;
+
+	int irq;
+	int irq_err;
+	int irq_bd;
+
+	struct clk *src_clk;
+	unsigned long clk_rate;
+	unsigned long clk_div;
+	unsigned long real_rate;
+
+	u32 current_rca;
+	bool is_multi_rw_only_one_blkcnt;
+};
+
